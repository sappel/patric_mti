<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TImpedance.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>TImpedance.cpp</h1><div class="fragment"><pre>00001 <span class="preprocessor">#include "obflib.h"</span>
00002 <span class="preprocessor">#include "mathtools.h"</span>
00003 <span class="preprocessor">#include "TImpedance.h"</span>
00004 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00005 
00010 <span class="keywordtype">double</span> Trans_Wake(<span class="keywordtype">double</span> z, <span class="keywordtype">double</span> omega0, <span class="keywordtype">double</span> R, <span class="keywordtype">double</span> tune0, <span class="keywordtype">double</span> nres, <span class="keywordtype">double</span> Rs, <span class="keywordtype">double</span> Qs)
00011 {
00012   <span class="keywordtype">double</span> omegar=(<a class="code" href="group__Impedance.html#a3">nres</a>-tune0)*omega0; 
00013   <span class="keywordtype">double</span> alpha=omegar/(2.0*<a class="code" href="group__Impedance.html#a4">Qs</a>);
00014   <span class="keywordtype">double</span> omegas=sqrt(pow(omegar,2)-pow(alpha,2));
00015   <span class="keywordtype">double</span> v0=omega0*R;
00016   <span class="keywordtype">double</span> R1s=<a class="code" href="group__Impedance.html#a2">Rs</a>*omegar/v0;
00017   <span class="keywordtype">double</span> wake=-R1s*v0*omegar/(<a class="code" href="group__Impedance.html#a4">Qs</a>*omegas)*exp(-alpha*z/v0)*sin(omegas*z/v0);
00018   <span class="keywordflow">if</span> (z &gt; 0) <span class="keywordflow">return</span> wake;
00019   <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0.0;
00020 }
00021 
00027 <span class="keywordtype">double</span> Trans_Wake(<span class="keywordtype">double</span> z, <span class="keywordtype">double</span> beta0, <span class="keywordtype">double</span> circum, <span class="keywordtype">double</span> b, <span class="keywordtype">double</span> leit)
00028 {
00029  <span class="keywordtype">double</span> Z0=377.0;       
00030  <span class="keywordtype">double</span> wake=-pow(beta0,1.5)*clight*<a class="code" href="group__Lattice.html#a1">circum</a>/(PI*pow(b,3)*sqrt(z))*sqrt(Z0/(PI*leit));  
00031  <span class="keywordflow">if</span> (z &gt; 0) <span class="keywordflow">return</span> wake;
00032  <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0.0;       
00033 }       
00034 
00035 
00041 <span class="keywordtype">void</span> InducedWakeKick(Grid1D&amp; kick,Grid1D&amp; dipole_current,Grid1D&amp; dipole_current_s,
00042                  <span class="keywordtype">double</span> tune, <span class="keywordtype">double</span> omega0, <span class="keywordtype">double</span> nres, <span class="keywordtype">double</span> Rs, <span class="keywordtype">double</span> Qs, <span class="keywordtype">double</span> b, <span class="keywordtype">double</span> leit, 
00043                  <span class="keywordtype">double</span> beta0, <span class="keywordtype">double</span> E0, <span class="keywordtype">double</span> charge) 
00044 {
00045   <span class="keywordtype">double</span> dz=dipole_current.get_dz();
00046   <span class="keywordtype">int</span> n=dipole_current.get_size();
00047   <span class="keywordtype">double</span> <a class="code" href="group__Lattice.html#a1">circum</a>=dz*n;
00048   <span class="keywordtype">double</span> R=<a class="code" href="group__Lattice.html#a1">circum</a>/(2.0*PI);
00049   <span class="keywordtype">double</span> tmp=0.0, psi=0.0, psis=0.0;
00050   <span class="keywordtype">int</span> turns=2; <span class="comment">// number of turns considered for integration (max. 3)</span>
00051   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++)    
00052      {
00053        tmp=0.0;    
00054        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;n*turns; k++)   <span class="comment">// integration along z</span>
00055             {
00056              <span class="keywordflow">if</span> (j+k &lt; n)
00057                     {
00058                      psi=dipole_current[j+k]/(beta0*clight);  <span class="comment">// psi: dipole moment at position z=(j+k)*dz</span>
00059                      psis=dipole_current_s[j+k]/(beta0*clight);
00060                     }
00061              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j+k &lt; 2*n)
00062                    {
00063                      psi=dipole_current[j+k-n]/(beta0*clight);  <span class="comment">// psi: dipole moment at position z=(j+k)*dz</span>
00064                      psis=dipole_current_s[j+k-n]/(beta0*clight);
00065                     }
00066              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j+k &lt; 3*n)
00067                    {
00068                      psi=dipole_current[j+k-2*n]/(beta0*clight);  <span class="comment">// psi: dipole moment at position z=(j+k)*dz</span>
00069                      psis=dipole_current_s[j+k-2*n]/(beta0*clight);
00070                    }
00071              <span class="keywordflow">else</span>
00072                   { psi=0.0; psis=0.0; }
00073           
00074               tmp+=dz*(psi*cos(-tune*k*dz/R)+R/tune*psis*sin(-tune*k*dz/R))
00075                    *(Trans_Wake(k*dz,omega0,circum/(2.0*PI),tune,nres,Rs,Qs)
00076                    + Trans_Wake(k*dz,beta0,circum,b,leit));         
00077             }
00078     
00079        kick[j]+=-charge/(pow(beta0,2)*E0)*tmp;    
00080      }
00081 }
00082 
00083 
00088 komplex Trans_Impedance(<span class="keywordtype">double</span> omega,<span class="keywordtype">double</span> omega0, <span class="keywordtype">double</span> tune0, <span class="keywordtype">double</span> nres, <span class="keywordtype">double</span> Rs, <span class="keywordtype">double</span> Qs)
00089 {
00090    komplex i(0.0,1.0);
00091    <span class="keywordtype">double</span> omegar=(<a class="code" href="group__Impedance.html#a3">nres</a>-tune0)*omega0; 
00092    komplex cavimp=(omegar/omega)*<a class="code" href="group__Impedance.html#a2">Rs</a>/(1.0-i*<a class="code" href="group__Impedance.html#a4">Qs</a>*(omega/omegar-omegar/omega));
00093    <span class="keywordflow">return</span> cavimp;
00094 }
00095 
00096 
00097 <span class="keywordtype">void</span> InducedKick(Grid1D&amp; kick, Grid1D&amp; dipole_current,   
00098                         <span class="keywordtype">double</span> Zimage, <span class="keywordtype">double</span> beta0, <span class="keywordtype">double</span> E0, <span class="keywordtype">double</span> charge) 
00099 {
00100  <span class="keywordtype">int</span> n=dipole_current.get_size();       
00101  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++)
00102     kick[j]+=-charge/(beta0*E0)*<a class="code" href="group__Impedance.html#a5">Zimage</a>*dipole_current[j];       
00103 }
00104 
00105 
00106 <span class="keywordtype">void</span> InducedKick(Grid1D&amp; kick, Grid1D&amp; dipole_current, Grid1D&amp; dipole_current_s,  
00107                  <span class="keywordtype">double</span> tune, <span class="keywordtype">double</span> omega0, <span class="keywordtype">double</span> nres, <span class="keywordtype">double</span> Rs, <span class="keywordtype">double</span> Qs, 
00108                  <span class="keywordtype">double</span> beta0, <span class="keywordtype">double</span> E0, <span class="keywordtype">double</span> charge, <span class="keywordtype">double</span> t) 
00109 {
00110         komplex i(0.0,1.0);
00111         <span class="keywordtype">double</span> bl_amp, bl_real, bl_imag, bl_phase; 
00112         <span class="keywordtype">double</span> dz=dipole_current.get_dz();
00113         <span class="keywordtype">int</span> n=dipole_current.get_size();
00114         <span class="keywordtype">double</span> <a class="code" href="group__Lattice.html#a1">circum</a>=dz*n;
00115         vektor psi_1(n), psi_2(n);
00116         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++) 
00117         { 
00118          psi_1[j]=dipole_current[j]*cos(omega0*tune*t)-<a class="code" href="group__Lattice.html#a1">circum</a>/(2.0*PI*tune)*dipole_current_s[j]*sin(omega0*tune*t);
00119          psi_2[j]=dipole_current[j]*sin(omega0*tune*t)+<a class="code" href="group__Lattice.html#a1">circum</a>/(2.0*PI*tune)*dipole_current_s[j]*cos(omega0*tune*t);
00120         }
00121         
00122         realft(psi_1,1);
00123         realft(psi_2,1);
00124         
00125         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> h=0; h &lt; n/2-1; h++)
00126         {
00127                 komplex temc1(psi_1[2*h],psi_1[2*h+1]);   <span class="comment">// dipole current amplitude </span>
00128                 komplex temc2(psi_2[2*h],psi_2[2*h+1]);   
00129                 <span class="keywordflow">if</span> ( h==0) { temc1=komplex(psi_1[0],0.0); 
00130                              temc2=komplex(psi_2[0],0.0); }
00131                 
00132                 komplex timpp=Trans_Impedance(omega0*(h+tune),omega0,tune,nres,Rs,Qs);<span class="comment">// fast wave</span>
00133                 komplex timpm=Trans_Impedance(omega0*(h-tune),omega0,tune,nres,Rs,Qs); <span class="comment">// slow wave</span>
00134                 
00135                 komplex temcp=i*timpp*(temc1-i*temc2)*exp(i*tune*omega0*t);
00136                 komplex temcm=i*timpm*(temc1+i*temc2)*exp(-i*tune*omega0*t);
00137                 
00138                 komplex temctot=temcp+temcm;
00139                 
00140                 psi_1[2*h]=temctot.real();
00141                 psi_1[2*h+1]=temctot.imag();
00142 
00143         }
00144 
00145         realft(psi_1,-1);
00146 
00147         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++)
00148                 kick[j]+=0.5*charge/(beta0*E0)*psi_1[j];    
00149 
00150         <span class="keywordflow">return</span>;
00151 }
00152 
00153 
00154 
00155 
00156 <span class="keywordtype">void</span> InducedKick(Grid1D&amp; kick,Grid1D&amp; dipole_current,
00157                  <span class="keywordtype">double</span> tune, <span class="keywordtype">double</span> omega0, <span class="keywordtype">double</span> nres, <span class="keywordtype">double</span> Rs, <span class="keywordtype">double</span> Qs, 
00158                  <span class="keywordtype">double</span> beta0, <span class="keywordtype">double</span> E0, <span class="keywordtype">double</span> charge) 
00159 {
00160         komplex i(0.0,1.0);
00161         <span class="keywordtype">double</span> bl_amp, bl_real, bl_imag, bl_phase; 
00162         <span class="keywordtype">double</span> dz=dipole_current.get_dz();
00163         <span class="keywordtype">int</span> n=dipole_current.get_size();
00164         <span class="keywordtype">double</span> <a class="code" href="group__Lattice.html#a1">circum</a>=dz*n;
00165         vektor <a class="code" href="group__Beam.html#a3">current</a>(n);
00166         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++) <a class="code" href="group__Beam.html#a3">current</a>[j]=dipole_current[j]; 
00167 
00168         realft(current,1);
00169         
00170         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> h=0; h &lt; n/2-1; h++)
00171         {
00172                 komplex temc(current[2*h],current[2*h+1]);   <span class="comment">// dipole current amplitude </span>
00173                 komplex temcc(current[2*h],-current[2*h+1]); <span class="comment">// complex conj.</span>
00174                 <span class="keywordflow">if</span> ( h==0) { temc=komplex(current[0],0.0); 
00175                              temcc=komplex(current[0],0.0); }
00176                 
00177                 komplex timpp=Trans_Impedance(omega0*(h+tune),omega0,tune,nres,Rs,Qs);<span class="comment">// fast wave</span>
00178                 komplex timpm=Trans_Impedance(omega0*(h-tune),omega0,tune,nres,Rs,Qs); <span class="comment">// slow wave</span>
00179                 
00180                 komplex temc2(0.0,0.0), temc3(0.0,0.0);
00181                 <span class="comment">//temc2=i*temc*i*timpm.imag(); // slow wave</span>
00182                 <span class="comment">//temc3=i*temc*i*timpp.imag();        // fast wave</span>
00183 
00184                 temc2=i*temc*(timpm.real()+i*0.5*(timpm.imag()+timpp.imag())); <span class="comment">// slow wave</span>
00185                 temc3=i*temcc*(timpp.real());        <span class="comment">// fast wave</span>
00186                 
00187                 bl_real = temc2.real()+temc3.real();
00188                 bl_imag = temc2.imag()+temc3.imag();
00189 
00190                 <a class="code" href="group__Beam.html#a3">current</a>[2*h]=bl_real;
00191                 <a class="code" href="group__Beam.html#a3">current</a>[2*h+1]=bl_imag;
00192 
00193         }
00194 
00195         realft(current,-1);
00196 
00197         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++)
00198                 kick[j]+=charge/(beta0*E0)*<a class="code" href="group__Beam.html#a3">current</a>[j]; <span class="comment">// factor 0.5 added !    </span>
00199 
00200         <span class="keywordflow">return</span>;
00201 }
00202 
00203 
00204 
00215 <span class="keywordtype">double</span> InducedKick(<span class="keywordtype">double</span> offset, <span class="keywordtype">double</span> ds, komplex dqc, <span class="keywordtype">double</span> beta0, <span class="keywordtype">double</span> tune, <span class="keywordtype">double</span> circum)
00216 {       
00217  <span class="keywordtype">double</span> dqr=dqc.real(), dqi=dqc.imag();
00218  <span class="keyword">static</span> <span class="keywordtype">double</span> offset_0=0.0;
00219  <span class="keywordtype">double</span> offset_d=(offset-offset_0)/ds;
00220  offset_0=offset;
00221  <span class="keywordtype">double</span> omega0=2.0*PI*beta0*clight/<a class="code" href="group__Lattice.html#a1">circum</a>;
00222  <span class="keywordflow">return</span> 8.0*PI*PI*tune/<a class="code" href="group__Lattice.html#a1">circum</a>*(-dqr*offset+dqi*beta0*clight*offset_d/(tune*omega0));    
00223 }
00224 
00225 
00226 
00227 
</pre></div><hr><address style="align: right;"><small>Generated on Wed Oct 14 14:27:07 2009 for Track by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3 </small></address>
</body>
</html>
