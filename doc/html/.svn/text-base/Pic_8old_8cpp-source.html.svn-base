<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Track: Pic.old.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">src</a></div>
<h1>Pic.old.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#include "mylib.h"</span>
00002 <span class="preprocessor">#include "SectorMap.h"</span>
00003 <span class="preprocessor">#include "Pic.h"</span>
00004 <span class="preprocessor">#include "mathtools.h"</span>
00005 
00006 <span class="comment">//-------------Anfangsverteilungen----------------------------</span>
00007 
00008 
00009 <span class="keywordtype">void</span> <a class="code" href="classPic.html#a5">Pic::waterbag_xy</a>(<span class="keywordtype">double</span> emittance_x, <span class="keywordtype">double</span> emittance_y, 
00010                <span class="keywordtype">double</span> alpha_x, <span class="keywordtype">double</span> alpha_y,
00011                <span class="keywordtype">double</span> beta_x, <span class="keywordtype">double</span> beta_y, <span class="keywordtype">double</span> D0, <span class="keywordtype">double</span> Ds0, 
00012                <span class="keywordtype">double</span> centering, <span class="keywordtype">long</span> *d)
00013 {
00014  <span class="keywordtype">long</span> j;
00015  <span class="keywordtype">double</span> x, y, xs, ys;
00016 
00017  <span class="keywordtype">double</span> xmax=sqrt(emittance_x*beta_x);
00018  <span class="keywordtype">double</span> xsmax=sqrt(emittance_x*(1.0+pow(alpha_x,2))/beta_x);  
00019  <span class="keywordtype">double</span> ymax=sqrt(emittance_y*beta_y);
00020  <span class="keywordtype">double</span> ysmax=sqrt(emittance_y*(1.0+pow(alpha_y,2))/beta_y);   
00021 
00022  <span class="keywordflow">for</span> (j=0 ; j &lt; pics.size() ; j++)  
00023    {
00024     <span class="keywordflow">do</span>
00025      {
00026       x=xmax*(2.0*ran1(d)-1.0);
00027       y=ymax*(2.0*ran1(d)-1.0);
00028       xs=xsmax*(2.0*ran1(d)-1.0);
00029       ys=ysmax*(2.0*ran1(d)-1.0); 
00030 
00031      }  <span class="keywordflow">while</span>( 1.0/emittance_x*(pow(x,2)/beta_x
00032               +pow(sqrt(beta_x)*xs+alpha_x/sqrt(beta_x)*x,2))
00033               +1.0/emittance_y*(pow(y,2)/beta_y
00034               +pow(sqrt(beta_y)*ys+alpha_y/sqrt(beta_y)*y,2)) &gt; 1.0 );       
00035         
00036     pics[j].x=x+centering+D0*pics[j].dp;  <span class="comment">// add dispersion and off-set</span>
00037     pics[j].xs=xs+Ds0*pics[j].dp;         <span class="comment">// Ds0 </span>
00038     pics[j].y=y;
00039     pics[j].ys=ys;
00040                
00041    }
00042 } 
00043 
00044 
<a name="l00045"></a><a class="code" href="classPic.html#a75">00045</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a6">Pic::KV_xy</a>(<span class="keywordtype">double</span> emittance_x, <span class="keywordtype">double</span> emittance_y, 
00046                <span class="keywordtype">double</span> alpha_x, <span class="keywordtype">double</span> alpha_y,
00047                <span class="keywordtype">double</span> beta_x, <span class="keywordtype">double</span> beta_y, <span class="keywordtype">double</span> D0, <span class="keywordtype">double</span> Ds0, <span class="keywordtype">long</span> *d)
00048 
00049 { 
00050   <span class="keywordtype">long</span>   j ;
00051   <span class="keywordtype">double</span>  u , v , w , rx, rsx, ry, rsy; 
00052          
00053   <span class="keywordflow">for</span> (j=0 ; j&lt;pics.size(); j++)
00054       { 
00055         u = ran1(d); 
00056         v = ran1(d); 
00057         w = ran1(d); 
00058                       
00059         rx = sqrt(u*emittance_x*beta_x);
00060         ry = sqrt(u*emittance_y*beta_y);
00061         pics[j].x = rx * cos(2.0*PI*v) + D0*pics[j].dp ;
00062         pics[j].y = ry * sin(2.0*PI*v) ;
00063 
00064         rsx = sqrt((1.0-u)*emittance_x/beta_x);
00065         rsy = sqrt((1.0-u)*emittance_y/beta_y);
00066         pics[j].xs = rsx * cos(2.0*PI*w) + Ds0*pics[j].dp ;
00067         pics[j].ys = rsy * sin(2.0*PI*w) ; 
00068       }
00069 }
00070 
00071 
<a name="l00072"></a><a class="code" href="classPic.html#a76">00072</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a7">Pic::SG</a>(<span class="keywordtype">double</span> emittance_x, <span class="keywordtype">double</span> emittance_y, 
00073              <span class="keywordtype">double</span> alpha_x, <span class="keywordtype">double</span> alpha_y,
00074              <span class="keywordtype">double</span> beta_x, <span class="keywordtype">double</span> beta_y, <span class="keywordtype">double</span> D0, <span class="keywordtype">double</span> Ds0, <span class="keywordtype">long</span> *d)
00075 {
00076   <span class="keywordtype">long</span>   j ;
00077   <span class="keywordtype">double</span>  u , v , w , s, rx, ry; 
00078          
00079   <span class="keywordtype">double</span> xsmax=sqrt(emittance_x*(1.0+pow(alpha_x,2))/beta_x);  
00080   <span class="keywordtype">double</span> ysmax=sqrt(emittance_y*(1.0+pow(alpha_y,2))/beta_y); 
00081   <span class="keywordtype">double</span> xsrms=0.5*xsmax;
00082   <span class="keywordtype">double</span> ysrms=0.5*ysmax;
00083 
00084   <span class="keywordflow">for</span> (j=0 ; j&lt;pics.size(); j++)
00085       { 
00086         u = ran1(d); 
00087         v = ran1(d); 
00088         w = ran1(d); 
00089                       
00090         rx = sqrt(u*emittance_x*beta_x);
00091         ry = sqrt(u*emittance_y*beta_y);
00092         pics[j].x = rx * cos(2.0*PI*v) + D0*pics[j].dp ;
00093         pics[j].y = ry * sin(2.0*PI*v) ;
00094 
00095         <span class="keywordflow">do</span> { u = 2.0 * ran1(d) - 1.0 ;  
00096                v = 2.0 * ran1(d) - 1.0 ;              
00097                s = u*u + v*v ; }
00098           <span class="keywordflow">while</span> (s &gt;= 1.0) ;
00099  
00100         pics[j].xs = xsrms * u * sqrt(-2.0*log(s)/s) + Ds0*pics[j].dp ;
00101         pics[j].ys = ysrms * v * sqrt(-2.0*log(s)/s) ;
00102  
00103       }
00104 }
00105 
00106 
00107 <span class="comment">// longitudinal:</span>
00108 
00109 <span class="keywordtype">void</span> <a class="code" href="classPic.html#a11">Pic::gaussz</a>(<span class="keywordtype">double</span> dp0, <span class="keywordtype">long</span> *d)
00110 {
00111   <span class="keywordtype">long</span>   j ;
00112   <span class="keywordtype">double</span>  u , v , s ;
00113   <span class="keywordflow">for</span> (j=0 ; j &lt; pics.size() ; j+=2)
00114       { <span class="keywordflow">do</span> { u = 2.0 * ran1(d) - 1.0 ;  
00115              v = 2.0 * ran1(d) - 1.0 ;              
00116              s = u*u + v*v ; }
00117            <span class="keywordflow">while</span> (s &gt;= 1.0) ;
00118  
00119         pics[j].dp   = dp0 * u * sqrt(-2.0*log(s)/s) ;
00120         pics[j+1].dp = dp0 * v * sqrt(-2.0*log(s)/s) ; }
00121 }
00122 
00123     
00124 <span class="keywordtype">void</span> <a class="code" href="classPic.html#a9">Pic::parabolic</a>(<span class="keywordtype">double</span> z0, <span class="keywordtype">double</span> zlm, <span class="keywordtype">double</span> dp0, <span class="keywordtype">long</span> Np, <span class="keywordtype">long</span> *d)
00125 { 
00126   <span class="keywordtype">long</span> i ;
00127   <span class="keywordtype">double</span>  r1 , r2, parab_b = 0.0;
00128   <a class="code" href="structParticle.html">Particle</a> tem;
00129   <span class="keywordflow">for</span> (i=0 ; i &lt; Np; i++)
00130       { 
00131        r1 = ran1(d);  
00132        r2 = ran1(d);     
00133        tem.<a class="code" href="structParticle.html#o2">z</a> = z0 + zlm/2.0 * sqrt(1.0-pow(1.0-r1,2.0/3.0)) 
00134                      * cos(2.0*PI*r2) ;
00135        tem.<a class="code" href="structParticle.html#o3">dp</a> = (dp0*sin(2.0*PI*r2) 
00136                    + parab_b*zlm/2.0*cos(2.0*PI*r2)) 
00137                   * sqrt(1.0-pow(1.0-r1,2.0/3.0)) ; 
00138        <span class="keywordflow">if</span>(tem.<a class="code" href="structParticle.html#o2">z</a> &gt;= <a class="code" href="classPic.html#o0">z1</a> &amp;&amp; tem.<a class="code" href="structParticle.html#o2">z</a> &lt; <a class="code" href="classPic.html#o1">z2</a>) 
00139          pics.push_back(tem);
00140       }
00141 }
00142 
00143 
00144 <span class="keywordtype">void</span> <a class="code" href="classPic.html#a12">Pic::coasting_beam</a>(<span class="keywordtype">long</span> Np, <span class="keywordtype">double</span> length, <span class="keywordtype">long</span> *d)
00145 {
00146   <span class="keywordtype">long</span> j;
00147   <a class="code" href="structParticle.html">Particle</a> tem;
00148   <span class="keywordflow">for</span> (j=0 ; j &lt; Np ; j++)
00149    {
00150     tem.<a class="code" href="structParticle.html#o2">z</a>=length*(ran1(d)-0.5);
00151     <span class="keywordflow">if</span>(tem.<a class="code" href="structParticle.html#o2">z</a> &gt;= <a class="code" href="classPic.html#o0">z1</a> &amp;&amp; tem.<a class="code" href="structParticle.html#o2">z</a> &lt; <a class="code" href="classPic.html#o1">z2</a>) 
00152         pics.push_back(tem);
00153    }
00154 }    
00155 
00156 
00157 <span class="comment">//--------------Teilchenbewegung---------------------------</span>
00158 
00159 
00160 <span class="keywordtype">void</span> <a class="code" href="classPic.html#a43">Pic::transport</a>(<a class="code" href="classSectorMap.html">SectorMap</a>* M, <span class="keywordtype">double</span> boundary)
00161  {
00162   vektor R0(6), R1(6);
00163   <span class="keywordtype">double</span> a,b,c,d;
00164 
00165   <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00166    {
00167     <span class="keywordflow">if</span>( j &gt;= pics.size() ) <span class="keywordflow">break</span>;
00168     R0[0]=pics[j].x;
00169     R0[1]=pics[j].xs;
00170     R0[2]=pics[j].y;
00171     R0[3]=pics[j].ys;
00172     R0[4]=pics[j].z/SP-&gt;<a class="code" href="structSynParticle.html#o2">beta0</a>;
00173     R0[5]=SP-&gt;<a class="code" href="structSynParticle.html#o2">beta0</a>*pics[j].dp;
00174     M-&gt;transport(R1,R0);
00175     pics[j].x=R1[0];
00176     pics[j].xs=R1[1];
00177     pics[j].y=R1[2];
00178     pics[j].ys=R1[3];
00179     pics[j].z=R1[4]*SP-&gt;<a class="code" href="structSynParticle.html#o2">beta0</a>; 
00180     pics[j].dp=R1[5]/SP-&gt;<a class="code" href="structSynParticle.html#o2">beta0</a>;
00181     
00182     a=pics[j].ah;b=pics[j].bh;c=pics[j].ch;d=pics[j].dh;
00183     pics[j].ah=a*M-&gt;get_T(0,0)+b*M-&gt;get_T(1,0);
00184     pics[j].bh=a*M-&gt;get_T(0,1)+b*M-&gt;get_T(1,1);
00185     pics[j].ch=c*M-&gt;get_T(0,0)+d*M-&gt;get_T(1,0);
00186     pics[j].dh=c*M-&gt;get_T(0,1)+d*M-&gt;get_T(1,1);
00187     a=pics[j].av;b=pics[j].bv;c=pics[j].cv;d=pics[j].dv;
00188     pics[j].av=a*M-&gt;get_T(2,2)+b*M-&gt;get_T(3,2);
00189     pics[j].bv=a*M-&gt;get_T(2,3)+b*M-&gt;get_T(2,2);
00190     pics[j].cv=c*M-&gt;get_T(2,2)+d*M-&gt;get_T(3,2);
00191     pics[j].dv=c*M-&gt;get_T(2,3)+d*M-&gt;get_T(3,3);
00192   
00193    <span class="keywordflow">if</span>( fabs(pics[j].x) &gt;= boundary || fabs(pics[j].y) &gt;= boundary )
00194        pics.erase(pics.begin()+j);
00195    }
00196  }
00197 
00198 
00199 <span class="keywordtype">void</span> <a class="code" href="classPic.html#a44">Pic::kick</a>(Grid2D&amp; Ex, Grid2D&amp; Ey, <span class="keywordtype">double</span> ds)
00200 {
00201  <span class="keywordtype">double</span> beta0=SP-&gt;<a class="code" href="structSynParticle.html#o2">beta0</a>, gamma0=SP-&gt;<a class="code" href="structSynParticle.html#o3">gamma0</a>, <a class="code" href="group__Beam.html#ga2">A</a>=SP-&gt;<a class="code" href="structSynParticle.html#o1">A</a>, <a class="code" href="group__Beam.html#ga1">Z</a>=SP-&gt;<a class="code" href="structSynParticle.html#o0">Z</a>;
00202  <span class="keywordtype">double</span> temp=qe*<a class="code" href="group__Beam.html#ga1">Z</a>/(mp*<a class="code" href="group__Beam.html#ga2">A</a>*pow(gamma0,3)*pow(beta0*clight,2))*ds;
00203  <span class="keywordtype">double</span> a,b,c,d,ex,ey;
00204  <span class="keywordtype">double</span> x0=offset_x();
00205  <span class="keywordtype">double</span> y0=offset_y();
00206 
00207  <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00208    { 
00209     ex=temp*Ex.Grid2PIC(pics[j].x,pics[j].y);
00210     ey=temp*Ey.Grid2PIC(pics[j].x,pics[j].y);
00211 
00212     <span class="comment">//momenta:</span>
00213 
00214     pics[j].xs+=ex; 
00215     pics[j].ys+=ey;
00216 
00217     <span class="comment">//phaseadvance:</span>
00218     
00219     a=pics[j].ah;b=pics[j].bh;c=pics[j].ch;d=pics[j].dh;
00220     pics[j].ah=a+b*(pics[j].x-x0)/sqrt(pow(pics[j].x-x0,2)+1.0e-14)
00221                   *ex/sqrt(pow(pics[j].x-x0,2)+pow(0.1*Ex.get_dx(),2));
00222     pics[j].bh=b;
00223     pics[j].ch=c+d*(pics[j].x-x0)/sqrt(pow(pics[j].x-x0,2)+1.0e-14)
00224                   *ex/sqrt(pow(pics[j].x-x0,2)+pow(0.1*Ex.get_dx(),2));
00225     pics[j].dh=d;
00226     a=pics[j].av;b=pics[j].bv;c=pics[j].cv;d=pics[j].dv;
00227     pics[j].av=a+b*pics[j].y/sqrt(pow(pics[j].y,2)+1.0e-14)
00228                   *ey/sqrt(pow(pics[j].y-y0,2)+pow(0.1*Ey.get_dy(),2));
00229     pics[j].bv=b;
00230     pics[j].cv=c+d*pics[j].y/sqrt(pow(pics[j].y,2)+1.0e-14)
00231                   *ey/sqrt(pow(pics[j].y-y0,2)+pow(0.1*Ey.get_dy(),2));
00232     pics[j].dv=d;
00233    
00234    }
00235  
00236 }
00237 
00238 <span class="keywordtype">void</span> <a class="code" href="classPic.html#a44">Pic::kick</a>(<span class="keywordtype">double</span> fx, <span class="keywordtype">double</span> fy)
00239 {
00240  
00241  <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00242    { 
00243     pics[j].xs+=fx*pics[j].x; 
00244     pics[j].ys+=fy*pics[j].y; 
00245    }
00246 }
00247 
00248 
00249 <span class="keywordtype">void</span> <a class="code" href="classPic.html#a47">Pic::cavity_kick</a>(<span class="keywordtype">double</span> voltage0, <span class="keywordtype">int</span> harmonic, <span class="keywordtype">double</span> R)
00250 {
00251   <span class="keywordtype">double</span> beta0=SP-&gt;<a class="code" href="structSynParticle.html#o2">beta0</a>, gamma0=SP-&gt;<a class="code" href="structSynParticle.html#o3">gamma0</a>, <a class="code" href="group__Beam.html#ga2">A</a>=SP-&gt;<a class="code" href="structSynParticle.html#o1">A</a>, <a class="code" href="group__Beam.html#ga1">Z</a>=SP-&gt;<a class="code" href="structSynParticle.html#o0">Z</a>;
00252   <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00253     pics[j].dp+=<a class="code" href="group__Beam.html#ga1">Z</a>*qe*voltage0*sin(harmonic*pics[j].z/R)/(<a class="code" href="group__Beam.html#ga2">A</a>*mp*pow(beta0*clight,2)); 
00254 }
00255 
<a name="l00256"></a><a class="code" href="classPic.html#a109">00256</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a44">Pic::kick</a>(NonlMap&amp; M)
00257 {
00258  vektor R0(6), R1(6);
00259   <span class="keywordtype">double</span> a,b,c,d;
00260 
00261   <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00262    {
00263     <span class="keywordflow">if</span>( j &gt;= pics.size() ) <span class="keywordflow">break</span>;
00264     R0[0]=pics[j].x;
00265     R0[1]=pics[j].xs;
00266     R0[2]=pics[j].y;
00267     R0[3]=pics[j].ys;
00268     R0[4]=pics[j].z/SP-&gt;<a class="code" href="structSynParticle.html#o2">beta0</a>;
00269     R0[5]=SP-&gt;<a class="code" href="structSynParticle.html#o2">beta0</a>*pics[j].dp;
00270     M.kick(R1,R0);
00271     pics[j].x=R1[0];
00272     pics[j].xs=R1[1];
00273     pics[j].y=R1[2];
00274     pics[j].ys=R1[3];
00275     pics[j].z=R1[4]*SP-&gt;<a class="code" href="structSynParticle.html#o2">beta0</a>; 
00276     pics[j].dp=R1[5]/SP-&gt;<a class="code" href="structSynParticle.html#o2">beta0</a>;
00277    }
00278 }
00279 
00280 <span class="comment">//----------------------intrabeam-scattering------------------------------</span>
00281 
00282 
00283 <span class="keywordtype">void</span> <a class="code" href="classPic.html#a55">Pic::langevin</a>(<span class="keywordtype">double</span> beta_fxy, <span class="keywordtype">double</span> beta_fz, <span class="keywordtype">double</span> Dxy, <span class="keywordtype">double</span> Dz, 
00284               <span class="keywordtype">double</span> ds, <span class="keywordtype">double</span> beta_x0, <span class="keywordtype">double</span> beta_y0, <span class="keywordtype">long</span>* d)
00285 {
00286  <span class="keywordtype">double</span> Rx, Ry, Rz;
00287  <span class="keywordtype">double</span> beta0=SP-&gt;<a class="code" href="structSynParticle.html#o2">beta0</a>, gamma0=SP-&gt;<a class="code" href="structSynParticle.html#o3">gamma0</a>, <a class="code" href="group__Beam.html#ga2">A</a>=SP-&gt;<a class="code" href="structSynParticle.html#o1">A</a>, <a class="code" href="group__Beam.html#ga1">Z</a>=SP-&gt;<a class="code" href="structSynParticle.html#o0">Z</a>;
00288  <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;pics.size(); j++)
00289    {
00290     Rx=0.0; Ry=0.0; Rz=0.0;  
00291     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l=1; l&lt;=10; l++)
00292     {
00293       Rx+=sqrt(24.0/10.0)*(ran1(d)-0.5);
00294       Ry+=sqrt(24.0/10.0)*(ran1(d)-0.5);
00295       Rz+=sqrt(24.0/10.0)*(ran1(d)-0.5);
00296     }      
00297          
00298     pics[j].xs+=-beta_fxy/(beta0*clight)*pics[j].xs*ds
00299                 +Rx*sqrt(Dxy*ds/(beta_x0*beta0*clight));      
00300     pics[j].x+=-beta_fxy/(beta0*clight)*pics[j].x*ds
00301                 +Rx*sqrt(beta_x0*Dxy*ds/(beta0*clight));         
00302 
00303     pics[j].ys+=-beta_fxy/(beta0*clight)*pics[j].ys*ds
00304                 +Ry*sqrt(Dxy*ds/(beta_y0*beta0*clight)); 
00305     pics[j].y+=-beta_fxy/(beta0*clight)*pics[j].y*ds
00306                 +Ry*sqrt(beta_y0*Dxy*ds/(beta0*clight));  
00307 
00308     pics[j].dp+=-beta_fz/(beta0*clight)*pics[j].dp*ds
00309                 +Rz*sqrt(Dz*ds/(beta0*clight));  
00310    }
00311 }
00312 
00313 <span class="comment">//--------------------Interpolations: Scatter-Gather---------</span>
00314 
00315 
00316 <span class="keywordtype">void</span> Pic::gatherZ(<span class="keywordtype">double</span> pic_charge,Grid1D&amp; target)
00317 {
00318  <span class="keywordtype">long</span> j;
00319  target.reset();
00320  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00321   target.Pic2Field(pic_charge,pics[j].z);
00322 }
00323 
00324 
00325 <span class="keywordtype">void</span> Pic::gatherX(<span class="keywordtype">double</span> pic_charge,Grid1D&amp; target)
00326 {
00327  <span class="keywordtype">long</span> j;
00328  target.reset();
00329  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00330   target.Pic2Field(pic_charge*pics[j].x,pics[j].z);
00331 }
00332 
00333 <span class="keywordtype">void</span> Pic::gatherY(<span class="keywordtype">double</span> pic_charge,Grid1D&amp; target)
00334 {
00335  <span class="keywordtype">long</span> j;
00336  target.reset();
00337  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00338   target.Pic2Field(pic_charge*pics[j].y,pics[j].z);
00339 }
00340 
00341 
00342 <span class="keywordtype">void</span> Pic::gatherXY(<span class="keywordtype">double</span> pic_charge,Grid2D&amp; target)
00343 {
00344  <span class="keywordtype">long</span> j;
00345  target.reset();
00346  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00347   target.Pic2Grid(pic_charge,pics[j].x,pics[j].y);
00348 }
00349 
00350 
00351 <span class="keywordtype">void</span> Pic::gatherXXs(<span class="keywordtype">double</span> pic_charge,Grid2D&amp; target)
00352 {
00353  <span class="keywordtype">long</span> j;
00354  target.reset();
00355  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00356   target.Pic2Grid(pic_charge,pics[j].x,pics[j].xs);
00357 }
00358 
00359 
00360 <span class="keywordtype">void</span> Pic::gatherYYs(<span class="keywordtype">double</span> pic_charge,Grid2D&amp; target)
00361 {
00362  <span class="keywordtype">long</span> j;
00363  target.reset();
00364  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00365   target.Pic2Grid(pic_charge,pics[j].y,pics[j].ys);
00366 }
00367 
00368 <span class="keywordtype">void</span> Pic::gatherXsYs(<span class="keywordtype">double</span> pic_charge,Grid2D&amp; target)
00369 {
00370  <span class="keywordtype">long</span> j;
00371  target.reset();
00372  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00373   target.Pic2Grid(pic_charge,pics[j].xs,pics[j].ys);
00374 }
00375 
00376 
00377 <span class="comment">//--------------------Slice2Slice-----------------------------</span>
00378 
00379 
00380 vector&lt;Particle&gt; Pic::get_particles_left(<span class="keywordtype">double</span> length)
00381 {
00382   vector&lt;Particle&gt; tem;
00383   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;pics.size(); j++)
00384       <span class="keywordflow">if</span>(pics[j].z &lt; <a class="code" href="classPic.html#o0">z1</a>)
00385         {
00386           <span class="keywordflow">if</span> (pics[j].z &lt; -0.5*length) pics[j].z+=length;
00387           tem.push_back(pics[j]);
00388           pics.erase(pics.begin()+j);
00389         }
00390   <span class="keywordflow">return</span> tem;
00391 }
00392 
00393 
00394 vector&lt;Particle&gt; Pic::get_particles_right(<span class="keywordtype">double</span> length)
00395 {
00396   vector&lt;Particle&gt; tem;
00397   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;pics.size(); j++)
00398       <span class="keywordflow">if</span>(pics[j].z &gt; <a class="code" href="classPic.html#o1">z2</a>)
00399         {
00400           <span class="keywordflow">if</span> (pics[j].z &gt; 0.5*length) pics[j].z-=length;
00401           tem.push_back(pics[j]);
00402           pics.erase(pics.begin()+j);
00403         }
00404   <span class="keywordflow">return</span> tem;
00405 }
00406 
00407 
00408 <span class="keywordtype">void</span> Pic::add_particles(vector&lt;Particle&gt;&amp; part)
00409 {
00410   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;part.size(); j++)
00411     pics.push_back(part[j]);
00412 }
00413 
00414 
00415 <span class="comment">//--------------------Ausgabe----------------------------------</span>
00416 
00417 
00418 <span class="keywordtype">void</span> <a class="code" href="classPic.html#a13">Pic::print</a>(<span class="keywordtype">int</span> subset)
00419 {
00420  <span class="keywordtype">long</span> j, jran, d=100;
00421  <span class="keywordflow">if</span>( subset &gt; pics.size() ) {printf(<span class="stringliteral">"subset &gt; NPIC\n"</span>); exit(0);}
00422  <span class="keywordtype">float</span> *tem=<span class="keyword">new</span> <span class="keywordtype">float</span>[8];
00423  <span class="keywordflow">for</span>(j=0; j&lt;subset; j++)
00424    {
00425     jran=(int)(ran1(&amp;d)*(pics.size()-2.0));
00426     tem[0]=pics[jran].x;
00427     tem[1]=pics[jran].xs;
00428     tem[2]=pics[jran].y;
00429     tem[3]=pics[jran].ys;
00430     tem[4]=pics[jran].dp;
00431     tem[5]=pics[jran].z;
00432     tem[6]=get_phaseadvance_h(jran);
00433     tem[7]=get_phaseadvance_v(jran);
00434     fwrite(tem,<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),8,out);    
00435    }
00436  fflush(out);
00437  <span class="keyword">delete</span> tem;
00438 }
00439 
00440 <span class="comment">//--------------------Momente-------------------------------------</span>
00441 
00442 
00443 <span class="keywordtype">double</span> Pic::rms_emittance_x()
00444 {
00445  <span class="keywordtype">long</span> j, n=pics.size();
00446  <span class="keywordtype">double</span> tem1=0.0, tem2=0.0, tem3=0.0, tem4=0.0, tem5=0.0;
00447  <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
00448    {
00449     tem4+=pics[j].x;
00450     tem5+=pics[j].xs;
00451    }  
00452  tem4/=n;
00453  tem5/=n;
00454 
00455  <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
00456    {
00457     tem1+=pow(pics[j].x-tem4,2);
00458     tem2+=pow(pics[j].xs-tem5,2);
00459     tem3+=(pics[j].x-tem4)*(pics[j].xs-tem5);  
00460    }
00461  <span class="keywordflow">return</span> sqrt(tem1*tem2/pow((<span class="keywordtype">double</span>)n,2)-pow(tem3/n,2)); 
00462 }
00463 
00464 
00465 <span class="keywordtype">double</span> Pic::rms_emittance_y()
00466 {
00467  <span class="keywordtype">long</span> j, n=pics.size();
00468  <span class="keywordtype">double</span> tem1=0.0, tem2=0.0, tem3=0.0;
00469  <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
00470    {
00471     tem1+=pow(pics[j].y,2);
00472     tem2+=pow(pics[j].ys,2);
00473     tem3+=pics[j].y*pics[j].ys;
00474    }
00475  <span class="keywordflow">return</span> sqrt(tem1*tem2/pow((<span class="keywordtype">double</span>)n,2)-pow(tem3/n,2)); 
00476 }
00477 
00478 
00479 <span class="keywordtype">double</span> Pic::x_rms()
00480 {
00481  <span class="keywordtype">long</span> j, n=pics.size();
00482  <span class="keywordtype">double</span> tem1=0.0, tem2=0.0;
00483  <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
00484    {
00485     tem1+=pow(pics[j].x,2);
00486     tem2+=pics[j].x;
00487    }
00488  <span class="keywordflow">return</span> sqrt(tem1/pics.size()-pow(tem2/pics.size(),2)); 
00489 }
00490 
00491 
00492 <span class="keywordtype">double</span> Pic::offset_x()
00493 {
00494  <span class="keywordtype">long</span> j, n=pics.size();
00495  <span class="keywordtype">double</span> tem1=0.0;
00496  <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
00497     tem1+=pics[j].x;  
00498  <span class="keywordflow">return</span> tem1/pics.size(); 
00499 }
00500 
00501 <span class="keywordtype">double</span> Pic::offset_y()
00502 {
00503  <span class="keywordtype">long</span> j, n=pics.size();
00504  <span class="keywordtype">double</span> tem1=0.0;
00505  <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
00506     tem1+=pics[j].y;  
00507  <span class="keywordflow">return</span> tem1/pics.size(); 
00508 }
00509 
00510 
00511 <span class="keywordtype">double</span> Pic::y_rms()
00512 {
00513  <span class="keywordtype">long</span> j;
00514  <span class="keywordtype">double</span> tem1=0.0, tem2=0.0;
00515  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00516    {
00517     tem1+=pow(pics[j].y,2);
00518     tem2+=pics[j].y;
00519    }
00520  <span class="keywordflow">return</span> sqrt(tem1/pics.size()-pow(tem2/pics.size(),2)); 
00521 }
00522 
00523 
00524 <span class="keywordtype">double</span> Pic::x2y2()
00525 {
00526  <span class="keywordtype">long</span> j;
00527  <span class="keywordtype">double</span> tem1=0.0, tem2=0.0;
00528  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00529    {
00530     tem1+=pow(pics[j].x*pics[j].y,2);
00531     tem2+=pics[j].x*pics[j].y;
00532    }
00533  <span class="keywordflow">return</span> tem1/pics.size()-pow(tem2/pics.size(),2); 
00534 }
00535 
00536 
00537 <span class="keywordtype">double</span> Pic::xy()
00538 {
00539  <span class="keywordtype">long</span> j;
00540  <span class="keywordtype">double</span> tem=0.0;
00541  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00542     tem+=pics[j].x*pics[j].y;
00543  <span class="keywordflow">return</span> tem/pics.size(); 
00544 }
00545 
00546 
00547 
00548 <span class="keywordtype">double</span> Pic::x_max()
00549 {
00550  <span class="keywordtype">long</span> j;
00551  <span class="keywordtype">double</span> tem=fabs(pics[0].x);
00552  <span class="keywordflow">for</span>(j=1; j&lt;pics.size(); j++)
00553    {
00554     <span class="keywordflow">if</span>( fabs(pics[j].x) &gt; tem )
00555       tem=fabs(pics[j].x);
00556    }
00557  <span class="keywordflow">return</span> tem;
00558 }
00559 
00560 
00561 <span class="keywordtype">double</span> Pic::y_max()
00562 {
00563  <span class="keywordtype">long</span> j;
00564  <span class="keywordtype">double</span> tem=fabs(pics[0].y);
00565  <span class="keywordflow">for</span>(j=1; j&lt;pics.size(); j++)
00566    {
00567     <span class="keywordflow">if</span>( fabs(pics[j].y) &gt; tem )
00568       tem=fabs(pics[j].y);
00569    }
00570  <span class="keywordflow">return</span> tem;
00571 }
00572 
00573 
00574 <span class="keywordtype">double</span> Pic::z_max()
00575 {
00576  <span class="keywordtype">long</span> j;
00577  <span class="keywordtype">double</span> tem=pics[0].z;
00578  <span class="keywordflow">for</span>(j=1; j&lt;pics.size(); j++)
00579    {
00580     <span class="keywordflow">if</span>( pics[j].z &gt; tem )
00581       tem=pics[j].z;
00582    }
00583  <span class="keywordflow">return</span> tem;
00584 }
00585 
00586 
00587 <span class="keywordtype">double</span> Pic::z_min()
00588 {
00589  <span class="keywordtype">long</span> j;
00590  <span class="keywordtype">double</span> tem=pics[0].z;
00591  <span class="keywordflow">for</span>(j=1; j&lt;pics.size(); j++)
00592    {
00593     <span class="keywordflow">if</span>( pics[j].z &lt; tem )
00594       tem=pics[j].z;
00595    }
00596  <span class="keywordflow">return</span> tem;
00597 }
00598 
00599 
00600 
00601 <span class="keywordtype">double</span> Pic::z_mean()
00602 { 
00603  <span class="keywordtype">long</span> j;
00604  <span class="keywordtype">double</span> tem=0.0;
00605  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00606    tem+=pics[j].z;
00607  <span class="keywordflow">return</span> tem/pics.size(); 
00608 }
00609 
00610 
00611 <span class="keywordtype">double</span> Pic::z2_mean()
00612 {
00613  <span class="keywordtype">long</span> j;
00614  <span class="keywordtype">double</span> tem=0.0;
00615  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00616    tem+=pow(pics[j].z,2);
00617  <span class="keywordflow">return</span> tem/pics.size(); 
00618 }
00619 
00620 
00621 <span class="keywordtype">double</span> Pic::rms_z_width()
00622 {
00623  <span class="keywordflow">return</span> sqrt(fabs(z2_mean()-pow(z_mean(),2))); 
00624 }
00625 
00626 
00627 <span class="keywordtype">double</span> Pic::pz_mean()
00628 {
00629  <span class="keywordtype">long</span> j;
00630  <span class="keywordtype">double</span> tem=0.0;
00631  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00632    tem+=pics[j].dp;
00633  <span class="keywordflow">return</span> tem/pics.size(); 
00634 }
00635 
00636 <span class="keywordtype">double</span> Pic::pz2_mean()
00637 {
00638  <span class="keywordtype">long</span> j;
00639  <span class="keywordtype">double</span> tem=0.0;
00640  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00641    tem+=pow(pics[j].dp,2);
00642  <span class="keywordflow">return</span> tem/pics.size(); 
00643 }
00644 
00645 <span class="keywordtype">double</span> Pic::rms_momentum_spread()
00646 {
00647  <span class="keywordflow">return</span> sqrt(fabs(pz2_mean()-pow(pz_mean(),2)));
00648 }
00649 
00650 
00651 <span class="comment">//--------------------Phase advance-------------------------------------</span>
00652 
00653 
00654 <span class="keywordtype">double</span> Pic::get_phaseadvance_h(<span class="keywordtype">int</span> j)
00655 {
00656  <span class="keywordflow">if</span>(fabs(pics[j].ah+pics[j].dh) &lt; 2.0)
00657   <span class="keywordflow">return</span> acos(0.5*(pics[j].ah+pics[j].dh));
00658  <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0.0;
00659 }
00660 
00661 
00662 <span class="keywordtype">double</span> Pic::get_phaseadvance_v(<span class="keywordtype">int</span> j)
00663 {
00664  <span class="keywordflow">if</span>(fabs(pics[j].av+pics[j].dv) &lt; 2.0)
00665   <span class="keywordflow">return</span> acos(0.5*(pics[j].av+pics[j].dv));
00666  <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0.0;
00667 }
00668 
00669 
00670 <span class="keywordtype">void</span> Pic::clear_maps()
00671 {
00672  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;pics.size(); j++)
00673    {
00674     pics[j].ah=1.0;
00675     pics[j].bh=0.0;     
00676     pics[j].ch=0.0;     
00677     pics[j].dh=1.0; 
00678     pics[j].av=1.0; 
00679     pics[j].bv=0.0; 
00680     pics[j].cv=0.0; 
00681     pics[j].dv=1.0; 
00682    }
00683 }
00684 
00685 <span class="keywordtype">void</span> Pic::set_maps(<a class="code" href="classSectorMap.html">SectorMap</a>* M)
00686 {
00687  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;pics.size(); j++)
00688    {
00689     pics[j].ah=M-&gt;<a class="code" href="classSectorMap.html#a9">get_T</a>(0,0);
00690     pics[j].bh=M-&gt;<a class="code" href="classSectorMap.html#a9">get_T</a>(0,1);
00691     pics[j].ch=M-&gt;<a class="code" href="classSectorMap.html#a9">get_T</a>(1,0);
00692     pics[j].dh=M-&gt;<a class="code" href="classSectorMap.html#a9">get_T</a>(1,1);
00693     pics[j].av=M-&gt;<a class="code" href="classSectorMap.html#a9">get_T</a>(2,2);
00694     pics[j].bv=M-&gt;<a class="code" href="classSectorMap.html#a9">get_T</a>(2,3);
00695     pics[j].cv=M-&gt;<a class="code" href="classSectorMap.html#a9">get_T</a>(3,2);
00696     pics[j].dv=M-&gt;<a class="code" href="classSectorMap.html#a9">get_T</a>(3,3);
00697    }
00698 }
00699 
00700 <span class="keywordtype">double</span> Pic::rms_phaseadvance_h()
00701  {
00702   <span class="keywordtype">double</span> tem=0.0;
00703   <span class="keywordtype">int</span> n=pics.size();
00704   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++)
00705     tem+=get_phaseadvance_h(j)/n;   
00706   <span class="keywordflow">return</span> tem;
00707  }
00708 
00709 
00710 <span class="keywordtype">double</span> Pic::rms_phaseadvance_v()
00711  {
00712   <span class="keywordtype">double</span> tem=0.0;
00713   <span class="keywordtype">int</span> n=pics.size();
00714   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++)
00715     tem+=get_phaseadvance_v(j)/n;   
00716   <span class="keywordflow">return</span> tem;
00717  }
00718 
00719 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jan 3 16:13:55 2007 for Track by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
