<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pic.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>Pic.cpp</h1><div class="fragment"><pre>00001 <span class="preprocessor">#include "obflib.h"</span>
00002 <span class="preprocessor">#include "SectorMap.h"</span>
00003 <span class="preprocessor">#include "Pic.h"</span>
00004 <span class="preprocessor">#include "mathtools.h"</span>
00005 
00006 <span class="comment">//-------------Anfangsverteilungen----------------------------</span>
00007  
00008 
<a name="l00009"></a><a class="code" href="classPic.html#a5">00009</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a5">Pic::waterbag_xy</a>(<span class="keywordtype">double</span> emittance_x, <span class="keywordtype">double</span> emittance_y, 
00010                <span class="keywordtype">double</span> alpha_x, <span class="keywordtype">double</span> alpha_y,
00011                <span class="keywordtype">double</span> beta_x, <span class="keywordtype">double</span> beta_y, <span class="keywordtype">double</span> D0, <span class="keywordtype">double</span> Ds0, 
00012                <span class="keywordtype">double</span> centering, <span class="keywordtype">double</span> circum, <span class="keywordtype">double</span> zlm, <span class="keywordtype">double</span> chroma, <span class="keywordtype">double</span> tunex, <span class="keywordtype">long</span> *d)
00013 {
00014  <span class="keywordtype">long</span> j;
00015  <span class="keywordtype">double</span> x, y, xs, ys;
00016  <span class="keywordtype">double</span> k_mode=1.0;
00017  <span class="keywordtype">double</span> xmax=sqrt(emittance_x*beta_x);
00018  <span class="keywordtype">double</span> xsmax=sqrt(emittance_x*(1.0+pow(alpha_x,2))/beta_x);  
00019  <span class="keywordtype">double</span> ymax=sqrt(emittance_y*beta_y);
00020  <span class="keywordtype">double</span> ysmax=sqrt(emittance_y*(1.0+pow(alpha_y,2))/beta_y);   
00021 
00022  <span class="keywordtype">double</span> chromx=-<a class="code" href="group__Other.html#a7">chroma</a>*0.5*tunex;  
00023 
00024  <span class="keywordflow">for</span> (j=0 ; j &lt; pics.size() ; j++)  
00025    {
00026     <span class="keywordflow">do</span>
00027      {
00028       x=xmax*(2.0*ran1(d)-1.0);
00029       y=ymax*(2.0*ran1(d)-1.0);
00030       xs=xsmax*(2.0*ran1(d)-1.0);
00031       ys=ysmax*(2.0*ran1(d)-1.0); 
00032 
00033      }  <span class="keywordflow">while</span>( 1.0/emittance_x*(pow(x,2)/beta_x
00034               +pow(sqrt(beta_x)*xs+alpha_x/sqrt(beta_x)*x,2))
00035               +1.0/emittance_y*(pow(y,2)/beta_y
00036               +pow(sqrt(beta_y)*ys+alpha_y/sqrt(beta_y)*y,2)) &gt; 1.0 );       
00037         
00038     pics[j].x=x+centering*cos(2.0*PI*chromx/SP-&gt;<a class="code" href="structSynParticle.html#m4">eta0</a>*(pics[j].z+zlm)/<a class="code" href="group__Lattice.html#a1">circum</a>)*cos(0.5*k_mode*PI*(pics[j].z+zlm)/zlm)+D0*pics[j].dp;  <span class="comment">// add dispersion and off-set !!!!!!     centering*pics[j].z/zlm</span>
00039     pics[j].xs=xs - 2.0*PI*tunex/<a class="code" href="group__Lattice.html#a1">circum</a>*centering*sin(2.0*PI*chromx/SP-&gt;<a class="code" href="structSynParticle.html#m4">eta0</a>*(pics[j].z+zlm)/<a class="code" href="group__Lattice.html#a1">circum</a>)*cos(0.5*k_mode*PI*(pics[j].z+zlm)/zlm) + Ds0*pics[j].dp;         <span class="comment">// Ds0 </span>
00040     pics[j].y=y;
00041     pics[j].ys=ys;
00042                
00043    }
00044 } 
00045 
00046 
<a name="l00047"></a><a class="code" href="classPic.html#a6">00047</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a6">Pic::KV_xy</a>(<span class="keywordtype">double</span> emittance_x, <span class="keywordtype">double</span> emittance_y, 
00048                <span class="keywordtype">double</span> alpha_x, <span class="keywordtype">double</span> alpha_y,
00049                <span class="keywordtype">double</span> beta_x, <span class="keywordtype">double</span> beta_y, <span class="keywordtype">double</span> D0, <span class="keywordtype">double</span> Ds0, <span class="keywordtype">double</span> centering, 
00050                <span class="keywordtype">double</span> nres, <span class="keywordtype">double</span> circum, <span class="keywordtype">double</span> zlm, <span class="keywordtype">double</span> chroma, <span class="keywordtype">double</span> tunex, <span class="keywordtype">long</span> *d)
00051 
00052 { 
00053   <span class="keywordtype">long</span>   j ;
00054   <span class="keywordtype">double</span>  u , v , w , rx, rsx, ry, rsy; 
00055   <span class="keywordtype">double</span> k_mode=1.0;
00056   <span class="keywordtype">double</span> chromx=-<a class="code" href="group__Other.html#a7">chroma</a>*0.5*tunex;   
00057       
00058   <span class="keywordflow">for</span> (j=0 ; j&lt;pics.size(); j++)
00059       { 
00060         u = ran1(d); 
00061         v = ran1(d); 
00062         w = ran1(d); 
00063                       
00064         rx = sqrt(u*emittance_x*beta_x);
00065         ry = sqrt(u*emittance_y*beta_y);
00066         pics[j].x = rx * cos(2.0*PI*v) + centering*cos(2.0*PI*chromx/SP-&gt;<a class="code" href="structSynParticle.html#m4">eta0</a>*(pics[j].z+zlm)/<a class="code" href="group__Lattice.html#a1">circum</a>)*cos(0.5*k_mode*PI*(pics[j].z+zlm)/zlm); <span class="comment">// *cos(2.0*PI*nres*pics[j].z/circum) + D0*pics[j].dp ;</span>
00067         pics[j].y = ry * sin(2.0*PI*v) ;
00068 
00069         rsx = sqrt((1.0-u)*emittance_x/beta_x) ;
00070         rsy = sqrt((1.0-u)*emittance_y/beta_y) ;
00071         pics[j].xs = rsx * cos(2.0*PI*w) - 2.0*PI*tunex/<a class="code" href="group__Lattice.html#a1">circum</a>*centering*sin(2.0*PI*chromx/SP-&gt;<a class="code" href="structSynParticle.html#m4">eta0</a>*(pics[j].z+zlm)/<a class="code" href="group__Lattice.html#a1">circum</a>)*cos(0.5*k_mode*PI*(pics[j].z+zlm)/zlm) + Ds0*pics[j].dp ;
00072         pics[j].ys = rsy * sin(2.0*PI*w) ; 
00073       }
00074 }
00075 
00076 
<a name="l00077"></a><a class="code" href="classPic.html#a7">00077</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a7">Pic::SG</a>(<span class="keywordtype">double</span> emittance_x, <span class="keywordtype">double</span> emittance_y, 
00078              <span class="keywordtype">double</span> alpha_x, <span class="keywordtype">double</span> alpha_y,
00079              <span class="keywordtype">double</span> beta_x, <span class="keywordtype">double</span> beta_y, <span class="keywordtype">double</span> D0, <span class="keywordtype">double</span> Ds0, <span class="keywordtype">double</span> centering, <span class="keywordtype">long</span> *d)
00080 {
00081   <span class="keywordtype">long</span>   j ;
00082   <span class="keywordtype">double</span>  u , v , w , s, rx, ry; 
00083          
00084   <span class="keywordtype">double</span> xsmax=sqrt(emittance_x*(1.0+pow(alpha_x,2))/beta_x);  
00085   <span class="keywordtype">double</span> ysmax=sqrt(emittance_y*(1.0+pow(alpha_y,2))/beta_y); 
00086   <span class="keywordtype">double</span> xsrms=0.5*xsmax;
00087   <span class="keywordtype">double</span> ysrms=0.5*ysmax;
00088 
00089   <span class="keywordflow">for</span> (j=0 ; j&lt;pics.size(); j++)
00090       { 
00091         u = ran1(d); 
00092         v = ran1(d); 
00093         w = ran1(d); 
00094                       
00095         rx = sqrt(u*emittance_x*beta_x);
00096         ry = sqrt(u*emittance_y*beta_y);
00097         pics[j].x = rx * cos(2.0*PI*v) + D0*pics[j].dp + centering ;
00098         pics[j].y = ry * sin(2.0*PI*v) ;
00099 
00100         <span class="keywordflow">do</span> { u = 2.0 * ran1(d) - 1.0 ;  
00101                v = 2.0 * ran1(d) - 1.0 ;              
00102                s = u*u + v*v ; }
00103           <span class="keywordflow">while</span> (s &gt;= 1.0) ;
00104  
00105         pics[j].xs = xsrms * u * sqrt(-2.0*log(s)/s) + Ds0*pics[j].dp ;
00106         pics[j].ys = ysrms * v * sqrt(-2.0*log(s)/s) ;
00107  
00108       }
00109 }
00110 
<a name="l00111"></a><a class="code" href="classPic.html#a8">00111</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a8">Pic::Gauss_xy</a>(<span class="keywordtype">double</span> emittance_x, <span class="keywordtype">double</span> emittance_y, 
00112              <span class="keywordtype">double</span> alpha_x, <span class="keywordtype">double</span> alpha_y,
00113              <span class="keywordtype">double</span> beta_x, <span class="keywordtype">double</span> beta_y, <span class="keywordtype">double</span> D0, <span class="keywordtype">double</span> Ds0, <span class="keywordtype">double</span> centering, <span class="keywordtype">long</span> *d)
00114 {
00115   <span class="keywordtype">long</span>   j ;
00116   <span class="keywordtype">double</span>  u , v , w , s; 
00117          
00118   <span class="keywordtype">double</span> xsrms=sqrt(emittance_x*(1.0+pow(alpha_x,2))/beta_x);  
00119   <span class="keywordtype">double</span> ysrms=sqrt(emittance_y*(1.0+pow(alpha_y,2))/beta_y); 
00120   <span class="keywordtype">double</span> rx = sqrt(emittance_x*beta_x);
00121   <span class="keywordtype">double</span> ry = sqrt(emittance_y*beta_y);
00122   
00123   <span class="keywordflow">for</span> (j=0 ; j&lt;pics.size(); j++)
00124       { 
00125               
00126         <span class="keywordflow">do</span> { u = 2.0 * ran1(d) - 1.0 ;  
00127                v = 2.0 * ran1(d) - 1.0 ;              
00128                w = u*u + v*v ; }
00129         <span class="keywordflow">while</span> (w &gt;= 1.0) ;
00130               
00131         pics[j].x = rx * u * sqrt(-2.0*log(w)/w) + D0*pics[j].dp + centering ;
00132         pics[j].y = ry * v * sqrt(-2.0*log(w)/w)   ;      
00133                     
00134         <span class="keywordflow">do</span> { u = 2.0 * ran1(d) - 1.0 ;  
00135                v = 2.0 * ran1(d) - 1.0 ;              
00136                s = u*u + v*v ; }
00137         <span class="keywordflow">while</span> (s &gt;= 1.0) ;
00138                       
00139         
00140         pics[j].xs = xsrms * u * sqrt(-2.0*log(s)/s) + Ds0*pics[j].dp ;
00141         pics[j].ys = ysrms * v * sqrt(-2.0*log(s)/s) ;
00142  
00143       }
00144 }
00145 
00146 
00147 <span class="comment">// longitudinal:</span>
00148 
<a name="l00149"></a><a class="code" href="classPic.html#a11">00149</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a11">Pic::gaussz</a>(<span class="keywordtype">double</span> dp0, <span class="keywordtype">long</span> *d)
00150 {
00151   <span class="keywordtype">long</span>   j ;
00152   <span class="keywordtype">double</span>  u , v , s ;
00153   <span class="keywordflow">for</span> (j=0 ; j &lt; pics.size() ; j+=2)
00154       { <span class="keywordflow">do</span> { u = 2.0 * ran1(d) - 1.0 ;  
00155              v = 2.0 * ran1(d) - 1.0 ;              
00156              s = u*u + v*v ; }
00157            <span class="keywordflow">while</span> (s &gt;= 1.0 ) ;
00158  
00159         pics[j].dp   = dp0 * u * sqrt(-2.0*log(s)/s) ;
00160         pics[j+1].dp = dp0 * v * sqrt(-2.0*log(s)/s) ; }
00161 }
00162 
00163     
<a name="l00164"></a><a class="code" href="classPic.html#a9">00164</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a9">Pic::parabolic</a>(<span class="keywordtype">double</span> z0, <span class="keywordtype">double</span> zlm, <span class="keywordtype">double</span> dp0, <span class="keywordtype">long</span> Np, <span class="keywordtype">long</span> *d)
00165 { 
00166   <span class="keywordtype">long</span> i ;
00167   <span class="keywordtype">double</span>  r1 , r2, parab_b = 0.0;
00168   <a class="code" href="structParticle.html">Particle</a> tem;
00169   <span class="keywordflow">for</span> (i=0 ; i &lt; Np; i++)
00170       { 
00171        r1 = ran1(d);  
00172        r2 = ran1(d);     
00173        tem.<a class="code" href="structParticle.html#m2">z</a> = z0 + zlm * sqrt(1.0-pow(1.0-r1,2.0/3.0)) 
00174                      * cos(2.0*PI*r2) ;
00175        tem.<a class="code" href="structParticle.html#m3">dp</a> = (dp0*sin(2.0*PI*r2) 
00176                    + parab_b*zlm*cos(2.0*PI*r2)) 
00177                   * sqrt(1.0-pow(1.0-r1,2.0/3.0)) ; 
00178        <span class="keywordflow">if</span>(tem.<a class="code" href="structParticle.html#m2">z</a> &gt;= <a class="code" href="classPic.html#m0">z1</a> &amp;&amp; tem.<a class="code" href="structParticle.html#m2">z</a> &lt; <a class="code" href="classPic.html#m1">z2</a>) 
00179          pics.push_back(tem);
00180       }
00181 }
00182 
00183 
<a name="l00184"></a><a class="code" href="classPic.html#a10">00184</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a10">Pic::parabolic_dc</a>(<span class="keywordtype">double</span> length, <span class="keywordtype">double</span> dp0, <span class="keywordtype">long</span> Np, <span class="keywordtype">long</span> *d)
00185 { 
00186   <span class="keywordtype">long</span> i ;
00187   <span class="keywordtype">double</span>  r1 , r2;
00188   
00189   <a class="code" href="classPic.html#a12">coasting_beam</a>(Np,length,d);
00190   
00191   <span class="keywordflow">for</span> (i=0 ; i &lt; pics.size() ; i++)
00192       { 
00193        r1 = ran1(d);  
00194        r2 = ran1(d);     
00195        pics[i].dp = dp0*sin(2.0*PI*r2) * sqrt(1.0-pow(1.0-r1,2.0/3.0)) ; 
00196       }
00197 }
00198 
00199 
<a name="l00200"></a><a class="code" href="classPic.html#a12">00200</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a12">Pic::coasting_beam</a>(<span class="keywordtype">long</span> Np, <span class="keywordtype">double</span> length, <span class="keywordtype">long</span> *d)
00201 {
00202   <span class="keywordtype">long</span> j;
00203   <a class="code" href="structParticle.html">Particle</a> tem;
00204   <span class="keywordflow">for</span> (j=0 ; j &lt; Np ; j++)
00205    {
00206     tem.<a class="code" href="structParticle.html#m2">z</a>=length*(ran1(d)-0.5);
00207     <span class="keywordflow">if</span>(tem.<a class="code" href="structParticle.html#m2">z</a> &gt;= <a class="code" href="classPic.html#m0">z1</a> &amp;&amp; tem.<a class="code" href="structParticle.html#m2">z</a> &lt; <a class="code" href="classPic.html#m1">z2</a>) 
00208         pics.push_back(tem);
00209    }
00210 }    
00211 
00212 
<a name="l00213"></a><a class="code" href="classPic.html#a13">00213</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a13">Pic::bunch_gauss</a>(<span class="keywordtype">double</span> zlm, <span class="keywordtype">double</span> dp0, <span class="keywordtype">long</span> Np, <span class="keywordtype">double</span> circum, <span class="keywordtype">long</span> *d)
00214 {
00215   <span class="keywordtype">long</span>   j ;
00216   <a class="code" href="structParticle.html">Particle</a> tem1, tem2;
00217   <span class="keywordtype">double</span>  u , v , s, zu, zv ;
00218   <span class="keywordflow">for</span> (j=0 ; j &lt; Np ; j+=2)
00219       { <span class="keywordflow">do</span> { u = 2.0 * ran1(d) - 1.0 ;  
00220              v = 2.0 * ran1(d) - 1.0 ;              
00221              s = u*u + v*v ; 
00222              zu = zlm * u * sqrt(-2.0*log(s)/s) ;
00223              zv = zlm * v * sqrt(-2.0*log(s)/s) ;
00224            }
00225            <span class="keywordflow">while</span> (s &gt;= 1.0 || abs(zu) &gt;= 0.5*<a class="code" href="group__Lattice.html#a1">circum</a> || abs(zv) &gt;= 0.5*<a class="code" href="group__Lattice.html#a1">circum</a> ) ;
00226                 tem1.<a class="code" href="structParticle.html#m2">z</a> = zu ;
00227                 tem2.<a class="code" href="structParticle.html#m2">z</a> = zv ;
00228         <span class="keywordflow">if</span>(tem1.<a class="code" href="structParticle.html#m2">z</a> &gt;= <a class="code" href="classPic.html#m0">z1</a> &amp;&amp; tem1.<a class="code" href="structParticle.html#m2">z</a> &lt; <a class="code" href="classPic.html#m1">z2</a>) 
00229                 pics.push_back(tem1); 
00230             <span class="keywordflow">if</span>(tem2.<a class="code" href="structParticle.html#m2">z</a> &gt;= <a class="code" href="classPic.html#m0">z1</a> &amp;&amp; tem2.<a class="code" href="structParticle.html#m2">z</a> &lt; <a class="code" href="classPic.html#m1">z2</a>) 
00231                pics.push_back(tem2);
00232       }
00233 }
00234 
00235 
<a name="l00236"></a><a class="code" href="classPic.html#a14">00236</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a14">Pic::bunch_const</a>(<span class="keywordtype">double</span> zlm, <span class="keywordtype">double</span> dp0, <span class="keywordtype">int</span> linrf, <span class="keywordtype">double</span> circum, <span class="keywordtype">long</span> Np, <span class="keywordtype">long</span> *d)
00237 {
00238  <span class="keywordtype">long</span> i ;
00239  <span class="keywordtype">double</span> r1, r2 ;
00240  <span class="keywordtype">double</span> R=<a class="code" href="group__Lattice.html#a1">circum</a>/(2.0*PI);
00241  <span class="keywordtype">double</span> Y2, Ym=1.0-cos(zlm/R);
00242  <span class="keywordflow">if</span> (linrf == 1)  Ym=0.5*pow(zlm/R,2);  
00243  <a class="code" href="structParticle.html">Particle</a> tem;
00244  <span class="keywordflow">for</span> (i=0 ; i &lt; Np; i++)
00245       {
00246        <span class="keywordflow">do</span> { 
00247            r1 = dp0*(2.0*ran1(d)-1.0);
00248                    r2 = zlm*(2.0*ran1(d)-1.0);
00249                Y2 = 1.0-cos(r2/R);  
00250                <span class="keywordflow">if</span> (linrf == 1) Y2=0.5*pow(r2/R,2); } 
00251            <span class="keywordflow">while</span> (pow(r1/dp0,2)+Y2/Ym &gt; 1.0) ;
00252        tem.<a class="code" href="structParticle.html#m2">z</a>=r2;
00253        tem.<a class="code" href="structParticle.html#m3">dp</a>=r1;   
00254        <span class="keywordflow">if</span>(tem.<a class="code" href="structParticle.html#m2">z</a> &gt;= <a class="code" href="classPic.html#m0">z1</a> &amp;&amp; tem.<a class="code" href="structParticle.html#m2">z</a> &lt; <a class="code" href="classPic.html#m1">z2</a>) 
00255          pics.push_back(tem);
00256       }
00257 }
00258 
<a name="l00259"></a><a class="code" href="classPic.html#a15">00259</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a15">Pic::barrier_air_bag</a>(<span class="keywordtype">double</span> zlm, <span class="keywordtype">double</span> dp0, <span class="keywordtype">long</span> Np, <span class="keywordtype">long</span> *d)
00260 {
00261         <span class="keywordtype">long</span> i ;
00262         <span class="keywordtype">double</span> r1, r2 ;
00263         <a class="code" href="structParticle.html">Particle</a> tem;
00264         <span class="keywordflow">for</span> (i=0 ; i &lt; Np; i++)
00265              {
00266                    r1=(2.0*ran1(d)-1.0);
00267                tem.<a class="code" href="structParticle.html#m3">dp</a> = r1/abs(r1)*dp0;
00268                    tem.<a class="code" href="structParticle.html#m2">z</a> = zlm*(2.0*ran1(d)-1.0);
00269            <span class="keywordflow">if</span>(tem.<a class="code" href="structParticle.html#m2">z</a> &gt;= <a class="code" href="classPic.html#m0">z1</a> &amp;&amp; tem.<a class="code" href="structParticle.html#m2">z</a> &lt; <a class="code" href="classPic.html#m1">z2</a>) 
00270                   pics.push_back(tem);          
00271              }
00272 }
00273 
<a name="l00274"></a><a class="code" href="classPic.html#a16">00274</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a16">Pic::bunch_air_bag</a>(<span class="keywordtype">double</span> zlm, <span class="keywordtype">double</span> dp0, <span class="keywordtype">double</span> circum, <span class="keywordtype">long</span> Np, <span class="keywordtype">long</span> *d)
00275 {
00276         <span class="keywordtype">long</span> i ;
00277          <span class="keywordtype">double</span> r1, r2 ;
00278          <span class="keywordtype">double</span> R=<a class="code" href="group__Lattice.html#a1">circum</a>/(2.0*PI);
00279          <span class="keywordtype">double</span> Y2, rho1, Ym=1.0-cos(zlm/R);
00280          <a class="code" href="structParticle.html">Particle</a> tem;
00281          <span class="keywordflow">for</span> (i=0 ; i &lt; Np; i++)
00282               {
00283                <span class="keywordflow">do</span> { 
00284                    r1 = 50.0*(2.0*ran1(d)-1.0);
00285                            r2 = zlm*(2.0*ran1(d)-1.0);
00286                    Y2 = 1.0-cos(r2/R); 
00287                            rho1 = 1.0/sqrt(1.0-Y2/Ym); 
00288                    }
00289                    <span class="keywordflow">while</span> ( rho1 &lt; abs(r1)) ;
00290                tem.<a class="code" href="structParticle.html#m2">z</a>=r2;
00291                    tem.<a class="code" href="structParticle.html#m3">dp</a>=r1/abs(r1)*dp0*sqrt(1.0-Y2/Ym);   
00292                <span class="keywordflow">if</span>(tem.<a class="code" href="structParticle.html#m2">z</a> &gt;= <a class="code" href="classPic.html#m0">z1</a> &amp;&amp; tem.<a class="code" href="structParticle.html#m2">z</a> &lt; <a class="code" href="classPic.html#m1">z2</a>) 
00293                  pics.push_back(tem);
00294               }
00295 }
00296 
00297 <span class="comment">//--------------Teilchenbewegung---------------------------</span>
00298 
00299 
<a name="l00300"></a><a class="code" href="classPic.html#a49">00300</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a49">Pic::transport</a>(<a class="code" href="classSectorMap.html">SectorMap</a>* M, <span class="keywordtype">double</span> boundary)
00301  {
00302   vektor R0(6), R1(6);
00303 
00304   <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00305    {
00306     <span class="keywordflow">if</span>( j &gt;= pics.size() ) <span class="keywordflow">break</span>;
00307     R0[0]=pics[j].x;
00308     R0[1]=pics[j].xs;
00309     R0[2]=pics[j].y;
00310     R0[3]=pics[j].ys;
00311     R0[4]=pics[j].z/SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>;
00312     R0[5]=SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>*pics[j].dp;
00313     M-&gt;<a class="code" href="classSectorMap.html#a15">transport</a>(R1,R0);
00314     pics[j].x=R1[0];
00315     pics[j].xs=R1[1];
00316     pics[j].y=R1[2];
00317     pics[j].ys=R1[3];
00318     <span class="comment">//pics[j].z=R1[4]*SP-&gt;beta0; </span>
00319     pics[j].z-=SP-&gt;<a class="code" href="structSynParticle.html#m4">eta0</a>*pics[j].dp*M-&gt;<a class="code" href="classSectorMap.html#a7">get_L</a>(); 
00320     <span class="comment">//pics[j].dp=R1[5]/SP-&gt;beta0;</span>
00321     
00322    <span class="keywordflow">if</span>( fabs(pics[j].x) &gt;= boundary || fabs(pics[j].y) &gt;= boundary )
00323        pics.erase(pics.begin()+j);
00324    }
00325  }
00326 
00327 
<a name="l00328"></a><a class="code" href="classPic.html#a50">00328</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a50">Pic::kick</a>(Grid2D&amp; Ex, Grid2D&amp; Ey, <span class="keywordtype">double</span> ds)
00329 {
00330  <span class="keywordtype">double</span> beta0=SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>, gamma0=SP-&gt;<a class="code" href="structSynParticle.html#m3">gamma0</a>, <a class="code" href="group__Beam.html#a2">A</a>=SP-&gt;<a class="code" href="structSynParticle.html#m1">A</a>, <a class="code" href="group__Beam.html#a1">Z</a>=SP-&gt;<a class="code" href="structSynParticle.html#m0">Z</a>;
00331  <span class="keywordtype">double</span> temp=qe*<a class="code" href="group__Beam.html#a1">Z</a>/(mp*<a class="code" href="group__Beam.html#a2">A</a>*pow(gamma0,3)*pow(beta0*clight,2))*ds;
00332  <span class="keywordtype">double</span> ex,ey;
00333 
00334  <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00335    { 
00336     ex=temp*Ex.Grid2PIC(pics[j].x,pics[j].y);
00337     ey=temp*Ey.Grid2PIC(pics[j].x,pics[j].y);
00338 
00339     <span class="comment">//momenta:</span>
00340 
00341     pics[j].xs+=ex; 
00342     pics[j].ys+=ey;
00343     
00344    }
00345 }
00346 
00347 
00348 <span class="keywordtype">void</span> <a class="code" href="classPic.html#a50">Pic::kick</a>(Grid3D&amp; Ex, Grid3D&amp; Ey, <span class="keywordtype">double</span> ds)
00349 {
00350  <span class="keywordtype">double</span> beta0=SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>, gamma0=SP-&gt;<a class="code" href="structSynParticle.html#m3">gamma0</a>, <a class="code" href="group__Beam.html#a2">A</a>=SP-&gt;<a class="code" href="structSynParticle.html#m1">A</a>, <a class="code" href="group__Beam.html#a1">Z</a>=SP-&gt;<a class="code" href="structSynParticle.html#m0">Z</a>;
00351  <span class="keywordtype">double</span> temp=qe*<a class="code" href="group__Beam.html#a1">Z</a>/(mp*<a class="code" href="group__Beam.html#a2">A</a>*pow(gamma0,3)*pow(beta0*clight,2))*ds;
00352  <span class="keywordtype">double</span> ex,ey;
00353  
00354  <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00355    { 
00356     ex=temp*Ex.Grid2PIC(pics[j].x,pics[j].y,pics[j].z);
00357     ey=temp*Ey.Grid2PIC(pics[j].x,pics[j].y,pics[j].z);
00358 
00359     <span class="comment">//momenta:</span>
00360 
00361     pics[j].xs+=ex; 
00362     pics[j].ys+=ey;
00363     
00364    }
00365  
00366 }
00367 
00368 
<a name="l00369"></a><a class="code" href="classPic.html#a52">00369</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a50">Pic::kick</a>(<span class="keywordtype">double</span> fx, <span class="keywordtype">double</span> fy)
00370 {
00371  
00372  <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00373    { 
00374     pics[j].xs+=fx; 
00375     pics[j].ys+=fy; 
00376    }
00377 }
00378 
00379 
<a name="l00380"></a><a class="code" href="classPic.html#a53">00380</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a53">Pic::cavity_kick</a>(<span class="keywordtype">double</span> voltage0, <span class="keywordtype">int</span> harmonic, <span class="keywordtype">double</span> R)
00381 {
00382   <span class="keywordtype">double</span> beta0=SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>, gamma0=SP-&gt;<a class="code" href="structSynParticle.html#m3">gamma0</a>, <a class="code" href="group__Beam.html#a2">A</a>=SP-&gt;<a class="code" href="structSynParticle.html#m1">A</a>, <a class="code" href="group__Beam.html#a1">Z</a>=SP-&gt;<a class="code" href="structSynParticle.html#m0">Z</a>;
00383   <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00384     pics[j].dp-=<a class="code" href="group__Beam.html#a1">Z</a>*qe*voltage0*sin(harmonic*pics[j].z/R)/(<a class="code" href="group__Beam.html#a2">A</a>*mp*gamma0*pow(beta0*clight,2)); 
00385 }
00386 
00387 <span class="keywordtype">void</span> Pic::cavity_kick_linear(<span class="keywordtype">double</span> voltage0, <span class="keywordtype">int</span> harmonic, <span class="keywordtype">double</span> R)
00388 {
00389   <span class="keywordtype">double</span> beta0=SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>, gamma0=SP-&gt;<a class="code" href="structSynParticle.html#m3">gamma0</a>, <a class="code" href="group__Beam.html#a2">A</a>=SP-&gt;<a class="code" href="structSynParticle.html#m1">A</a>, <a class="code" href="group__Beam.html#a1">Z</a>=SP-&gt;<a class="code" href="structSynParticle.html#m0">Z</a>;
00390   <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00391     pics[j].dp-=<a class="code" href="group__Beam.html#a1">Z</a>*qe*voltage0*(harmonic*pics[j].z/R)/(<a class="code" href="group__Beam.html#a2">A</a>*mp*gamma0*pow(beta0*clight,2)); 
00392 }
00393 
00394 
<a name="l00395"></a><a class="code" href="classPic.html#a55">00395</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a55">Pic::barrier_kick</a>(<span class="keywordtype">double</span> zm1, <span class="keywordtype">double</span> zm2)
00396 {
00397   <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00398    {
00399      <span class="keywordflow">if</span> (pics[j].z &lt;= zm1 &amp;&amp; pics[j].dp &lt; 0.0)
00400              pics[j].dp=-pics[j].dp;
00401      <span class="keywordflow">if</span> (pics[j].z &gt;= zm2 &amp;&amp; pics[j].dp &gt; 0.0)
00402              pics[j].dp=-pics[j].dp;         
00403    }
00404 }
00405 
00406 
<a name="l00407"></a><a class="code" href="classPic.html#a56">00407</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a50">Pic::kick</a>(<a class="code" href="classThinLens.html">ThinLens</a>&amp; M, <span class="keywordtype">double</span> ds)
00408 {
00409   vektor R0(6), R1(6);
00410 
00411   <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00412    {
00413     <span class="keywordflow">if</span>( j &gt;= pics.size() ) <span class="keywordflow">break</span>;
00414     R0[0]=pics[j].x;
00415     R0[1]=pics[j].xs;
00416     R0[2]=pics[j].y;
00417     R0[3]=pics[j].ys;
00418     R0[4]=pics[j].z;
00419     R0[5]=pics[j].dp;
00420     M.<a class="code" href="classThinLens.html#a0">kick</a>(R1,R0,ds);
00421     pics[j].x=R1[0];
00422     pics[j].xs=R1[1];
00423     pics[j].y=R1[2];
00424     pics[j].ys=R1[3];
00425     pics[j].z=R1[4];
00426     pics[j].dp=R1[5];
00427    }
00428 }
00429 
<a name="l00430"></a><a class="code" href="classPic.html#a57">00430</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a57">Pic::impedance_kick</a>(Grid1D&amp; kick, <span class="keywordtype">double</span> circum, <span class="keywordtype">double</span> ds)
00431 {
00432   <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00433         pics[j].xs+=ds/<a class="code" href="group__Lattice.html#a1">circum</a>*kick.Field2Pic(pics[j].z);  
00434 }
00435 
00436 
<a name="l00437"></a><a class="code" href="classPic.html#a58">00437</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a58">Pic::linear_SC_kick</a>(<span class="keywordtype">double</span> dQxm, <span class="keywordtype">double</span> dQym, <span class="keywordtype">double</span> tunex, <span class="keywordtype">double</span> tuney, 
00438                          Grid1D&amp; ldy, <span class="keywordtype">double</span> ldy0, 
00439                          Grid1D&amp; dipole_current_x, Grid1D&amp; dipole_current_y, 
00440                          <span class="keywordtype">double</span> circum, <span class="keywordtype">double</span> ds)
00441 {
00442  <span class="keywordtype">double</span> R=<a class="code" href="group__Lattice.html#a1">circum</a>/(2.0*PI);
00443  <span class="keywordtype">double</span> scfact;
00444  <span class="keywordtype">double</span> offsetx;
00445  <span class="keywordtype">double</span> offsety;
00446  
00447  <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00448   {
00449    scfact=ldy.Field2Pic(pics[j].z)/ldy0;
00450    <span class="keywordflow">if</span> ( scfact &gt; 0.0 )
00451     {
00452      offsetx=dipole_current_x.Field2Pic(pics[j].z)/(SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>*clight*ldy0*scfact);
00453      offsety=dipole_current_y.Field2Pic(pics[j].z)/(SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>*clight*ldy0*scfact);
00454      pics[j].xs-=scfact*2.0*ds*tunex*<a class="code" href="group__Lattice.html#a9">dQxm</a>/pow(R,2)*(pics[j].x-offsetx); 
00455      pics[j].ys-=scfact*2.0*ds*tuney*<a class="code" href="group__Lattice.html#a10">dQym</a>/pow(R,2)*(pics[j].y-offsety);
00456     }
00457   }
00458 }
00459 
00460 
00461 <span class="keywordtype">void</span> Pic::nonlinear_SC_kick(<span class="keywordtype">double</span> xrms, <span class="keywordtype">double</span> yrms, <span class="keywordtype">double</span> dQxm, <span class="keywordtype">double</span> dQym, <span class="keywordtype">double</span> tunex, <span class="keywordtype">double</span> tuney, 
00462                             Grid1D&amp; ldy, <span class="keywordtype">double</span> ldy0, <span class="keywordtype">double</span> circum, <span class="keywordtype">double</span> ds)
00463 {
00464  <span class="keywordtype">double</span> R=<a class="code" href="group__Lattice.html#a1">circum</a>/(2.0*PI);
00465  <span class="keywordtype">double</span> scfact;
00466  <span class="keywordtype">double</span> offsetx=offset_x();
00467  <span class="keywordtype">double</span> offsety=offset_y();
00468  
00469  <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00470   {
00471    scfact=ldy.Field2Pic(pics[j].z)/ldy0;
00472    
00473    <span class="comment">//if( pow(pics[j].x-offsetx,2)+pow(pics[j].y-offsety,2) &lt; 6.0*(pow(xrms,2)+pow(yrms,2)) ) </span>
00474     <span class="comment">//{   </span>
00475      pics[j].xs-=scfact*2.0*ds*tunex*<a class="code" href="group__Lattice.html#a9">dQxm</a>/pow(R,2)*(pics[j].x-offsetx)*(1.0
00476          -1.0/18.0*(2.0*xrms+yrms)/(xrms*xrms*(xrms+yrms))*pow(pics[j].x-offsetx,2)
00477          -1.0/(6.0*yrms*(xrms+yrms))*pow(pics[j].y-offsety,2));
00478      pics[j].ys-=scfact*2.0*ds*tuney*<a class="code" href="group__Lattice.html#a10">dQym</a>/pow(R,2)*(pics[j].y-offsety)*(1.0
00479          -1.0/18.0*(2.0*yrms+xrms)/(yrms*yrms*(xrms+yrms))*pow(pics[j].y-offsety,2)
00480          -1.0/(6.0*xrms*(xrms+yrms))*pow(pics[j].x-offsetx,2));
00481     <span class="comment">//}</span>
00482   }
00483 }
00484 
00485 
00486 <span class="keywordtype">void</span> Pic::dipole_kick_simple(<span class="keywordtype">double</span> dQxm, <span class="keywordtype">double</span> dQym, <span class="keywordtype">double</span> tunex, <span class="keywordtype">double</span> tuney, 
00487                              Grid1D&amp; ldy, <span class="keywordtype">double</span> ldy0, 
00488                              Grid1D&amp; dipole_current_x, Grid1D&amp; dipole_current_y, 
00489                              <span class="keywordtype">double</span> circum, <span class="keywordtype">double</span> ds)
00490 {
00491  <span class="keywordtype">double</span> R=<a class="code" href="group__Lattice.html#a1">circum</a>/(2.0*PI);
00492  <span class="keywordtype">double</span> scfact;
00493  <span class="keywordtype">double</span> offsetx;
00494  <span class="keywordtype">double</span> offsety;
00495  
00496  <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00497   {
00498    scfact=ldy.Field2Pic(pics[j].z)/ldy0;
00499    <span class="keywordflow">if</span> ( scfact &gt; 0.0 )
00500     {
00501      offsetx=dipole_current_x.Field2Pic(pics[j].z)/(SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>*clight*ldy0*scfact);
00502      offsety=dipole_current_y.Field2Pic(pics[j].z)/(SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>*clight*ldy0*scfact);
00503      pics[j].xs-=scfact*2.0*ds*tunex*<a class="code" href="group__Lattice.html#a9">dQxm</a>/pow(R,2)*offsetx; 
00504      pics[j].ys-=scfact*2.0*ds*tuney*<a class="code" href="group__Lattice.html#a10">dQym</a>/pow(R,2)*offsety;
00505     }
00506   }
00507 }
00508 
00509 
<a name="l00529"></a><a class="code" href="classPic.html#a61">00529</a> <span class="keywordtype">double</span> <a class="code" href="classPic.html#a61">Pic::dipole_mod_kick</a>(<span class="keywordtype">double</span> t, <span class="keywordtype">double</span> ds, <span class="keywordtype">double</span> circum, <span class="keywordtype">double</span> theta, <span class="keywordtype">double</span> freq0, 
00530                             <span class="keywordtype">double</span> freq1, <span class="keywordtype">double</span> tend, <span class="keywordtype">int</span> n, <span class="keywordtype">long</span>* d)
00531 {
00532   <span class="keywordtype">double</span> dtheta=0.0, R=<a class="code" href="group__Lattice.html#a1">circum</a>/(2.0*PI), beta0=SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>;
00533   <span class="keywordtype">double</span> dfreq=1.0/(tend);
00534   <span class="keyword">const</span> <span class="keywordtype">int</span> Nran_max=10000;
00535   <span class="keywordtype">int</span> Nran=(int)floor((freq1-freq0)/dfreq);
00536   <span class="keyword">static</span> <span class="keywordtype">int</span> flag=0;
00537   <span class="keyword">static</span> <span class="keywordtype">double</span> freq[Nran_max];
00538   <span class="keyword">static</span> <span class="keywordtype">double</span> phase[Nran_max];
00539   <span class="keywordflow">if</span> (Nran &gt;= Nran_max) { cout &lt;&lt; <span class="stringliteral">"dipole kick: Nran &gt; Nran_max !"</span>; exit(0); }
00540   
00541   <span class="keywordflow">if</span> (flag==0)
00542           {
00543            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;Nran; j++)
00544                    {
00545                     <span class="comment">//freq[j]=freq0+(freq1-freq0)*ran1(d);</span>
00546                     freq[j]=floor(freq0/dfreq)*dfreq+j*dfreq;
00547                     phase[j]=PI*ran1(d); 
00548                    }       
00549            flag=1;        
00550           }
00551           
00552   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=0; l&lt;Nran; l++)
00553           dtheta+=theta*cos(2.0*PI*freq[l]*t+phase[l])/Nran;
00554   
00555   <span class="keywordflow">if</span> (t &lt; 20.0/freq0)
00556           dtheta=dtheta*t*freq0/20.0; 
00557   
00558   <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00559    {   
00560     pics[j].xs+=ds/R*dtheta*cos(n/R*pics[j].z);
00561    }
00562    
00563  <span class="keywordflow">return</span> 0.5*dtheta*beta0*clight*cos(n/R*beta0*clight*t);
00564 }
00565 
00566 
<a name="l00567"></a><a class="code" href="classPic.html#a62">00567</a> <span class="keywordtype">double</span> <a class="code" href="classPic.html#a61">Pic::dipole_mod_kick</a>(<span class="keywordtype">double</span> t, <span class="keywordtype">double</span> ds, <span class="keywordtype">double</span> circum, <span class="keywordtype">double</span> theta, <span class="keywordtype">double</span> freq, <span class="keywordtype">int</span> n)
00568 {
00569   <span class="keywordtype">double</span> dtheta=0.0, R=<a class="code" href="group__Lattice.html#a1">circum</a>/(2.0*PI), beta0=SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>;
00570   
00571   dtheta=theta*cos(2.0*PI*freq*t);
00572   
00573   <span class="keywordflow">if</span> (t &lt; 20.0/freq)
00574           dtheta=dtheta*t*freq/20.0; 
00575   
00576   <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j = 0; j &lt; pics.size(); j++)
00577    {   
00578     pics[j].xs+=ds/R*dtheta*sin(n/R*pics[j].z);
00579    }
00580    
00581  <span class="keywordflow">return</span> 0.5*dtheta*beta0*clight*sin(n/R*beta0*clight*t);
00582 }
00583 
00584 
00585 
<a name="l00586"></a><a class="code" href="classPic.html#a63">00586</a> <span class="keywordtype">double</span> <a class="code" href="classPic.html#a63">Pic::pickup_signal</a>(Grid1D&amp; dipole_current, <span class="keywordtype">double</span> circum, <span class="keywordtype">double</span> t)
00587 {
00588  <span class="keywordtype">double</span> beta0=SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>;
00589  <span class="keywordtype">double</span> z0=0.5*<a class="code" href="group__Lattice.html#a1">circum</a>-fmod(clight*beta0*t,<a class="code" href="group__Lattice.html#a1">circum</a>); <span class="comment">// -0.5*circum;</span>
00590  <span class="keywordflow">return</span> dipole_current.get_grid_lin(z0);
00591 }
00592 
00593 
00594 <span class="comment">//----------------------intrabeam-scattering------------------------------</span>
00595 
00596 
<a name="l00597"></a><a class="code" href="classPic.html#a64">00597</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a64">Pic::langevin</a>(<span class="keywordtype">double</span> beta_fxy, <span class="keywordtype">double</span> beta_fz, <span class="keywordtype">double</span> Dxy, <span class="keywordtype">double</span> Dz, 
00598               <span class="keywordtype">double</span> ds, <span class="keywordtype">double</span> beta_x0, <span class="keywordtype">double</span> beta_y0, <span class="keywordtype">long</span>* d)
00599 {
00600  <span class="keywordtype">double</span> Rx, Ry, Rz;
00601  <span class="keywordtype">double</span> beta0=SP-&gt;<a class="code" href="structSynParticle.html#m2">beta0</a>, gamma0=SP-&gt;<a class="code" href="structSynParticle.html#m3">gamma0</a>, <a class="code" href="group__Beam.html#a2">A</a>=SP-&gt;<a class="code" href="structSynParticle.html#m1">A</a>, <a class="code" href="group__Beam.html#a1">Z</a>=SP-&gt;<a class="code" href="structSynParticle.html#m0">Z</a>;
00602  <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;pics.size(); j++)
00603    {
00604     Rx=0.0; Ry=0.0; Rz=0.0;  
00605     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l=1; l&lt;=10; l++)
00606     {
00607       Rx+=sqrt(24.0/10.0)*(ran1(d)-0.5);
00608       Ry+=sqrt(24.0/10.0)*(ran1(d)-0.5);
00609       Rz+=sqrt(24.0/10.0)*(ran1(d)-0.5);
00610     }      
00611          
00612     pics[j].xs+=-beta_fxy/(beta0*clight)*pics[j].xs*ds
00613                 +Rx*sqrt(Dxy*ds/(beta_x0*beta0*clight));      
00614     pics[j].x+=-beta_fxy/(beta0*clight)*pics[j].x*ds
00615                 +Rx*sqrt(beta_x0*Dxy*ds/(beta0*clight));         
00616 
00617     pics[j].ys+=-beta_fxy/(beta0*clight)*pics[j].ys*ds
00618                 +Ry*sqrt(Dxy*ds/(beta_y0*beta0*clight)); 
00619     pics[j].y+=-beta_fxy/(beta0*clight)*pics[j].y*ds
00620                 +Ry*sqrt(beta_y0*Dxy*ds/(beta0*clight));  
00621 
00622     pics[j].dp+=-beta_fz/(beta0*clight)*pics[j].dp*ds
00623                 +Rz*sqrt(Dz*ds/(beta0*clight));  
00624    }
00625 }
00626 
00627 <span class="comment">//--------------------Interpolations: Scatter-Gather---------</span>
00628 
00629 
00630 <span class="keywordtype">void</span> Pic::gatherZ(<span class="keywordtype">double</span> pic_charge,Grid1D&amp; target)
00631 {
00632  <span class="keywordtype">long</span> j;
00633  target.reset();
00634  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00635   target.Pic2Field(pic_charge,pics[j].z);
00636 }
00637 
00638 
00639 <span class="keywordtype">void</span> Pic::gatherX(<span class="keywordtype">double</span> pic_charge,Grid1D&amp; target)
00640 {
00641  <span class="keywordtype">long</span> j;
00642  target.reset();
00643  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00644   target.Pic2Field(pic_charge*pics[j].x,pics[j].z);
00645 }
00646 
00647 <span class="keywordtype">void</span> Pic::gatherXs(<span class="keywordtype">double</span> pic_charge,Grid1D&amp; target)
00648 {
00649  <span class="keywordtype">long</span> j;
00650  target.reset();
00651  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00652   target.Pic2Field(pic_charge*pics[j].xs,pics[j].z);
00653 }
00654 
00655 
00656 <span class="keywordtype">void</span> Pic::gatherY(<span class="keywordtype">double</span> pic_charge,Grid1D&amp; target)
00657 {
00658  <span class="keywordtype">long</span> j;
00659  target.reset();
00660  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00661   target.Pic2Field(pic_charge*pics[j].y,pics[j].z);
00662 }
00663 
00664 
00665 <span class="keywordtype">void</span> Pic::gatherXY(<span class="keywordtype">double</span> pic_charge,Grid2D&amp; target)
00666 {
00667  <span class="keywordtype">long</span> j;
00668  target.reset();
00669  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00670   target.Pic2Grid(pic_charge,pics[j].x,pics[j].y);
00671 }
00672 
00673 <span class="keywordtype">void</span> Pic::gatherZX(<span class="keywordtype">double</span> pic_charge,Grid2D&amp; target)
00674 {
00675  <span class="keywordtype">long</span> j;
00676  target.reset();
00677  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00678   target.Pic2Grid(pic_charge,pics[j].z,pics[j].x);
00679 }
00680 
00681 
00682 <span class="keywordtype">void</span> Pic::gatherXXs(<span class="keywordtype">double</span> pic_charge,Grid2D&amp; target)
00683 {
00684  <span class="keywordtype">long</span> j;
00685  target.reset();
00686  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00687   target.Pic2Grid(pic_charge,pics[j].x,pics[j].xs);
00688 }
00689 
00690 
00691 <span class="keywordtype">void</span> Pic::gatherYYs(<span class="keywordtype">double</span> pic_charge,Grid2D&amp; target)
00692 {
00693  <span class="keywordtype">long</span> j;
00694  target.reset();
00695  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00696   target.Pic2Grid(pic_charge,pics[j].y,pics[j].ys);
00697 }
00698 
00699 <span class="keywordtype">void</span> Pic::gatherXsYs(<span class="keywordtype">double</span> pic_charge,Grid2D&amp; target)
00700 {
00701  <span class="keywordtype">long</span> j;
00702  target.reset();
00703  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00704   target.Pic2Grid(pic_charge,pics[j].xs,pics[j].ys);
00705 }
00706 
00707 <span class="keywordtype">void</span> Pic::gatherXYZ(<span class="keywordtype">double</span> pic_charge,Grid3D&amp; target)
00708 {
00709  <span class="keywordtype">long</span> j;
00710  target.reset();
00711  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00712   target.Pic2Grid(pic_charge,pics[j].x,pics[j].y,pics[j].z);
00713 }
00714 
00715 
00716 
00717 <span class="comment">//--------------------Slice2Slice-----------------------------</span>
00718 
00719 
00720 vector&lt;Particle&gt; Pic::get_particles_left(<span class="keywordtype">double</span> length)
00721 {
00722   vector&lt;Particle&gt; tem;
00723   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;pics.size(); j++)
00724       <span class="keywordflow">if</span>(pics[j].z &lt; <a class="code" href="classPic.html#m0">z1</a>)
00725         {
00726           <span class="keywordflow">if</span> (pics[j].z &lt; -0.5*length) pics[j].z+=length;
00727           tem.push_back(pics[j]);
00728           pics.erase(pics.begin()+j);
00729         }       
00730   <span class="keywordflow">return</span> tem;
00731 }
00732 
00733 
00734 <span class="keywordtype">void</span> Pic::periodic_bc(<span class="keywordtype">double</span> length)
00735 {
00736  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;pics.size(); j++)
00737      {
00738       <span class="keywordflow">if</span> (pics[j].z &lt; -0.5*length) pics[j].z+=length;
00739       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pics[j].z &gt; 0.5*length) pics[j].z-=length;
00740      }
00741 }
00742 
00743 
00744 vector&lt;Particle&gt; Pic::get_particles_right(<span class="keywordtype">double</span> length)
00745 {
00746   vector&lt;Particle&gt; tem;
00747   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;pics.size(); j++)
00748       <span class="keywordflow">if</span>(pics[j].z &gt; <a class="code" href="classPic.html#m1">z2</a>)
00749         {
00750           <span class="keywordflow">if</span> (pics[j].z &gt; 0.5*length) pics[j].z-=length;
00751           tem.push_back(pics[j]);
00752           pics.erase(pics.begin()+j);
00753         }
00754   <span class="keywordflow">return</span> tem;
00755 }
00756 
00757 
00758 <span class="keywordtype">void</span> Pic::add_particles(vector&lt;Particle&gt;&amp; part)
00759 {
00760   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;part.size(); j++)
00761     pics.push_back(part[j]);
00762 }
00763 
00764 
00765 <span class="comment">//--------------------Ausgabe----------------------------------</span>
00766 
00767 
<a name="l00768"></a><a class="code" href="classPic.html#a17">00768</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a17">Pic::print</a>(<span class="keywordtype">int</span> subset)
00769 {
00770  <span class="keywordtype">long</span> j, jran, d=100;
00771  <span class="keywordflow">if</span>( subset &gt; pics.size() ) {printf(<span class="stringliteral">"subset &gt; NPIC\n"</span>); exit(0);}
00772  <span class="keywordtype">float</span> *tem=<span class="keyword">new</span> <span class="keywordtype">float</span>[8];
00773  <span class="keywordflow">for</span>(j=0; j&lt;subset; j++)
00774    {
00775     jran=(int)(ran1(&amp;d)*(pics.size()-2.0));
00776     tem[0]=pics[jran].x;
00777     tem[1]=pics[jran].xs;
00778     tem[2]=pics[jran].y;
00779     tem[3]=pics[jran].ys;
00780     tem[4]=pics[jran].dp;
00781     tem[5]=pics[jran].z;
00782     tem[6]=get_phaseadvance_h(jran); <span class="comment">//   get_wavelength_h(jran);</span>
00783     tem[7]=get_phaseadvance_v(jran); <span class="comment">//     get_wavelength_v(jran);</span>
00784     fwrite(tem,<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),8,out);    
00785    }
00786  fflush(out);
00787  <span class="keyword">delete</span> tem;
00788 }
00789 
00790 <span class="comment">//--------------------Momente-------------------------------------</span>
00791 
00792 
00793 <span class="keywordtype">double</span> Pic::rms_emittance_x()
00794 {
00795  <span class="keywordtype">long</span> j, n=pics.size();
00796  <span class="keywordtype">double</span> tem1=0.0, tem2=0.0, tem3=0.0, tem4=0.0, tem5=0.0;
00797  <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
00798    {
00799     tem4+=pics[j].x;
00800     tem5+=pics[j].xs;
00801    }  
00802  tem4/=n;
00803  tem5/=n;
00804 
00805  <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
00806    {
00807     tem1+=pow(pics[j].x-tem4,2);
00808     tem2+=pow(pics[j].xs-tem5,2);
00809     tem3+=(pics[j].x-tem4)*(pics[j].xs-tem5);  
00810    }
00811  <span class="keywordflow">return</span> sqrt(tem1*tem2/pow((<span class="keywordtype">double</span>)n,2)-pow(tem3/n,2)); 
00812 }
00813 
00814 
00815 <span class="keywordtype">double</span> Pic::rms_emittance_y()
00816 {
00817  <span class="keywordtype">long</span> j, n=pics.size();
00818  <span class="keywordtype">double</span> tem1=0.0, tem2=0.0, tem3=0.0;
00819  <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
00820    {
00821     tem1+=pow(pics[j].y,2);
00822     tem2+=pow(pics[j].ys,2);
00823     tem3+=pics[j].y*pics[j].ys;
00824    }
00825  <span class="keywordflow">return</span> sqrt(tem1*tem2/pow((<span class="keywordtype">double</span>)n,2)-pow(tem3/n,2)); 
00826 }
00827 
00828 
00829 <span class="keywordtype">double</span> Pic::x_rms()
00830 {
00831  <span class="keywordtype">long</span> j, n=pics.size();
00832  <span class="keywordtype">double</span> tem1=0.0, tem2=0.0;
00833  <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
00834    {
00835     tem1+=pow(pics[j].x,2);
00836     tem2+=pics[j].x;
00837    }
00838  <span class="keywordflow">return</span> sqrt(tem1/pics.size()-pow(tem2/pics.size(),2)); 
00839 }
00840 
00841 
00842 <span class="keywordtype">double</span> Pic::offset_x()
00843 {
00844  <span class="keywordtype">long</span> j, n=pics.size();
00845  <span class="keywordtype">double</span> tem1=0.0;
00846  <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
00847     tem1+=pics[j].x;  
00848  <span class="keywordflow">return</span> tem1/pics.size(); 
00849 }
00850 
00851 <span class="keywordtype">double</span> Pic::offset_y()
00852 {
00853  <span class="keywordtype">long</span> j, n=pics.size();
00854  <span class="keywordtype">double</span> tem1=0.0;
00855  <span class="keywordflow">for</span>(j=0; j&lt;n; j++)
00856     tem1+=pics[j].y;  
00857  <span class="keywordflow">return</span> tem1/pics.size(); 
00858 }
00859 
00860 
00861 <span class="keywordtype">double</span> Pic::y_rms()
00862 {
00863  <span class="keywordtype">long</span> j;
00864  <span class="keywordtype">double</span> tem1=0.0, tem2=0.0;
00865  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00866    {
00867     tem1+=pow(pics[j].y,2);
00868     tem2+=pics[j].y;
00869    }
00870  <span class="keywordflow">return</span> sqrt(tem1/pics.size()-pow(tem2/pics.size(),2)); 
00871 }
00872 
00873 
00874 <span class="keywordtype">double</span> Pic::x2y2()
00875 {
00876  <span class="keywordtype">long</span> j;
00877  <span class="keywordtype">double</span> tem1=0.0, tem2=0.0;
00878  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00879    {
00880     tem1+=pow(pics[j].x*pics[j].y,2);
00881     tem2+=pics[j].x*pics[j].y;
00882    }
00883  <span class="keywordflow">return</span> tem1/pics.size()-pow(tem2/pics.size(),2); 
00884 }
00885 
00886 
00887 <span class="keywordtype">double</span> Pic::xy()
00888 {
00889  <span class="keywordtype">long</span> j;
00890  <span class="keywordtype">double</span> tem=0.0;
00891  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00892     tem+=pics[j].x*pics[j].y;
00893  <span class="keywordflow">return</span> tem/pics.size(); 
00894 }
00895 
00896 <span class="keywordtype">double</span> Pic::xzn(<span class="keywordtype">double</span> k_mode, <span class="keywordtype">double</span> zlm)
00897 {
00898  <span class="keywordtype">long</span> j;
00899  <span class="keywordtype">double</span> tem=0.0;
00900  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00901         tem+=pics[j].x*cos(0.5*k_mode*PI*(pics[j].z+zlm)/zlm);
00902  <span class="keywordflow">return</span> tem/pics.size(); 
00903 }
00904 
00905 
00906 <span class="keywordtype">double</span> Pic::x_max()
00907 {
00908  <span class="keywordtype">long</span> j;
00909  <span class="keywordtype">double</span> tem=fabs(pics[0].x);
00910  <span class="keywordflow">for</span>(j=1; j&lt;pics.size(); j++)
00911    {
00912     <span class="keywordflow">if</span>( fabs(pics[j].x) &gt; tem )
00913       tem=fabs(pics[j].x);
00914    }
00915  <span class="keywordflow">return</span> tem;
00916 }
00917 
00918 
00919 <span class="keywordtype">double</span> Pic::y_max()
00920 {
00921  <span class="keywordtype">long</span> j;
00922  <span class="keywordtype">double</span> tem=fabs(pics[0].y);
00923  <span class="keywordflow">for</span>(j=1; j&lt;pics.size(); j++)
00924    {
00925     <span class="keywordflow">if</span>( fabs(pics[j].y) &gt; tem )
00926       tem=fabs(pics[j].y);
00927    }
00928  <span class="keywordflow">return</span> tem;
00929 }
00930 
00931 
00932 <span class="keywordtype">double</span> Pic::z_max()
00933 {
00934  <span class="keywordtype">long</span> j;
00935  <span class="keywordtype">double</span> tem=pics[0].z;
00936  <span class="keywordflow">for</span>(j=1; j&lt;pics.size(); j++)
00937    {
00938     <span class="keywordflow">if</span>( pics[j].z &gt; tem )
00939       tem=pics[j].z;
00940    }
00941  <span class="keywordflow">return</span> tem;
00942 }
00943 
00944 
00945 <span class="keywordtype">double</span> Pic::z_min()
00946 {
00947  <span class="keywordtype">long</span> j;
00948  <span class="keywordtype">double</span> tem=pics[0].z;
00949  <span class="keywordflow">for</span>(j=1; j&lt;pics.size(); j++)
00950    {
00951     <span class="keywordflow">if</span>( pics[j].z &lt; tem )
00952       tem=pics[j].z;
00953    }
00954  <span class="keywordflow">return</span> tem;
00955 }
00956 
00957 
00958 
00959 <span class="keywordtype">double</span> Pic::z_mean()
00960 { 
00961  <span class="keywordtype">long</span> j;
00962  <span class="keywordtype">double</span> tem=0.0;
00963  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00964    tem+=pics[j].z;
00965  <span class="keywordflow">return</span> tem/pics.size(); 
00966 }
00967 
00968 
00969 <span class="keywordtype">double</span> Pic::z2_mean()
00970 {
00971  <span class="keywordtype">long</span> j;
00972  <span class="keywordtype">double</span> tem=0.0;
00973  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00974    tem+=pow(pics[j].z,2);
00975  <span class="keywordflow">return</span> tem/pics.size(); 
00976 }
00977 
00978 
00979 <span class="keywordtype">double</span> Pic::rms_z_width()
00980 {
00981  <span class="keywordflow">return</span> sqrt(fabs(z2_mean()-pow(z_mean(),2))); 
00982 }
00983 
00984 
00985 <span class="keywordtype">double</span> Pic::pz_mean()
00986 {
00987  <span class="keywordtype">long</span> j;
00988  <span class="keywordtype">double</span> tem=0.0;
00989  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00990    tem+=pics[j].dp;
00991  <span class="keywordflow">return</span> tem/pics.size(); 
00992 }
00993 
00994 <span class="keywordtype">double</span> Pic::pz2_mean()
00995 {
00996  <span class="keywordtype">long</span> j;
00997  <span class="keywordtype">double</span> tem=0.0;
00998  <span class="keywordflow">for</span>(j=0; j&lt;pics.size(); j++)
00999    tem+=pow(pics[j].dp,2);
01000  <span class="keywordflow">return</span> tem/pics.size(); 
01001 }
01002 
01003 <span class="keywordtype">double</span> Pic::rms_momentum_spread()
01004 {
01005  <span class="keywordflow">return</span> sqrt(fabs(pz2_mean()-pow(pz_mean(),2)));
01006 }
01007 
01008 <span class="keywordtype">double</span> Pic::entropy(Grid2D&amp; target)
01009 {
01010  <span class="keywordtype">double</span> Hfunc=0.0;
01011  <span class="keywordtype">int</span> <a class="code" href="group__Particles.html#a0">NPIC</a>=get_size();
01012  <span class="keywordtype">int</span> Nxs=target.get_NX();
01013  <span class="keywordtype">int</span> Nys=target.get_NY();
01014  <span class="keywordtype">double</span> dxs=target.get_dx();
01015  <span class="keywordtype">double</span> dys=target.get_dy();
01016  gatherXsYs(1.0/(<span class="keywordtype">double</span>)NPIC,target);  
01017  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;Nxs; j++)
01018          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l=0; l&lt;Nys; l++)
01019          {   
01020            <span class="keywordflow">if</span> (target(j,l) &gt; 0.0)        
01021                 Hfunc+=target(j,l)*log(target(j,l))*dxs*dys;
01022          }
01023  <span class="keywordflow">return</span> Hfunc;
01024 }
01025 
01026 
01027 <span class="comment">//--------------------Phase advance-------------------------------------</span>
01028 
01029 
01030 <span class="keywordtype">void</span> Pic::update_wavelength_h(<span class="keywordtype">double</span> ds, <span class="keywordtype">double</span> offset_x)
01031 {
01032  <span class="keywordtype">int</span> n=pics.size();
01033  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++) 
01034   {
01035     <span class="keywordflow">if</span> ( pics[j].x &gt; offset_x &amp;&amp; pics[j].x1 &gt; offset_x )
01036             pics[j].lambda_tmp_h+=ds;
01037     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( pics[j].x &lt; offset_x &amp;&amp; pics[j].x1 &lt; offset_x )
01038             pics[j].lambda_tmp_h+=ds;     
01039     <span class="keywordflow">else</span>           
01040     {
01041             pics[j].lambda_tmp_h+=(offset_x-pics[j].x1)*ds/(pics[j].x-pics[j].x1);
01042             pics[j].lambda_h=pics[j].lambda_tmp_h;
01043             pics[j].lambda_tmp_h=0.0;
01044     }
01045     
01046     pics[j].x1=pics[j].x;
01047   }
01048 }
01049 
01050 
01051 <span class="keywordtype">void</span> Pic::update_wavelength_v(<span class="keywordtype">double</span> ds)
01052 {
01053  <span class="keywordtype">int</span> n=pics.size();
01054  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++) 
01055   {
01056     <span class="keywordflow">if</span> ( pics[j].y &gt; 0.0 &amp;&amp; pics[j].y1 &gt; 0.0 )
01057             pics[j].lambda_tmp_v+=ds;
01058     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( pics[j].y &lt; 0.0 &amp;&amp; pics[j].y1 &lt; 0.0 )
01059             pics[j].lambda_tmp_v+=ds;     
01060     <span class="keywordflow">else</span>           
01061     {
01062             pics[j].lambda_tmp_v+=-pics[j].y1*ds/(pics[j].y-pics[j].y1);
01063             pics[j].lambda_v=pics[j].lambda_tmp_v;
01064             pics[j].lambda_tmp_v=0.0;
01065     }
01066     
01067     pics[j].y1=pics[j].y;
01068   }
01069 }
01070 
01071 
<a name="l01079"></a><a class="code" href="classPic.html#a44">01079</a> <span class="keywordtype">void</span> <a class="code" href="classPic.html#a44">Pic::store_old_coordinates</a>()
01080 {
01081  <span class="keywordtype">int</span> n=pics.size();
01082  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++) 
01083   {
01084    pics[j].x2=pics[j].x1;
01085    pics[j].xs2=pics[j].xs1;
01086    pics[j].x1=pics[j].x;
01087    pics[j].xs1=pics[j].xs;
01088    pics[j].y2=pics[j].y1;
01089    pics[j].ys2=pics[j].ys1;
01090    pics[j].y1=pics[j].y;
01091    pics[j].ys1=pics[j].ys;
01092   }
01093 }
01094 
01095 
<a name="l01102"></a><a class="code" href="classPic.html#a40">01102</a> <span class="keywordtype">double</span> <a class="code" href="classPic.html#a40">Pic::get_wavelength_h</a>(<span class="keywordtype">int</span> j)
01103 {
01104  <span class="keywordflow">return</span> pics[j].lambda_h;
01105 }
01106 
01107 
01108 <span class="keywordtype">double</span> Pic::get_phaseadvance_h(<span class="keywordtype">int</span> j)
01109 {
01110  <span class="keywordtype">double</span> ah, dh; 
01111  <span class="keywordtype">double</span> x=pics[j].x,xs=pics[j].xs,
01112         x1=pics[j].x1,xs1=pics[j].xs1,
01113         x2=pics[j].x2,xs2=pics[j].xs2;
01114         
01115  <span class="keywordflow">if</span>( fabs(x1-x2*xs1/xs2) &gt; 0.0) 
01116    ah=(x-x1*xs1/xs2)/(x1-x2*xs1/xs2);
01117  <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0.0;
01118  
01119  <span class="keywordflow">if</span> (fabs(xs1-xs2*x1/x2) &gt; 0.0 )
01120    dh=(xs-xs1*x1/x2)/(xs1-xs2*x1/x2);
01121  <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0.0;
01122  
01123  <span class="keywordflow">if</span>( fabs(ah+dh) &lt; 2.0)
01124    <span class="keywordflow">return</span> acos(0.5*(ah+dh));
01125  <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0.0;
01126 }
01127 
01128 
<a name="l01135"></a><a class="code" href="classPic.html#a41">01135</a> <span class="keywordtype">double</span> <a class="code" href="classPic.html#a41">Pic::get_wavelength_v</a>(<span class="keywordtype">int</span> j)
01136 {
01137  <span class="keywordflow">return</span> pics[j].lambda_v;
01138 }
01139 
01140 
01141 <span class="keywordtype">double</span> Pic::get_phaseadvance_v(<span class="keywordtype">int</span> j)
01142 {
01143  <span class="keywordtype">double</span> av, dv; 
01144  <span class="keywordtype">double</span> y=pics[j].y,ys=pics[j].ys,
01145         y1=pics[j].y1,ys1=pics[j].ys1,
01146         y2=pics[j].y2,ys2=pics[j].ys2;
01147         
01148  <span class="keywordflow">if</span>( fabs(y1-y2*ys1/ys2) &gt; 0.0) 
01149    av=(y-y1*ys1/ys2)/(y1-y2*ys1/ys2);
01150  <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0.0;
01151  
01152  <span class="keywordflow">if</span> (fabs(ys1-ys2*y1/y2) &gt; 0.0 )
01153    dv=(ys-ys1*y1/y2)/(ys1-ys2*y1/y2);
01154  <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0.0;
01155  
01156  <span class="keywordflow">if</span>( fabs(av+dv) &lt; 2.0)
01157    <span class="keywordflow">return</span> acos(0.5*(av+dv));
01158  <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0.0;
01159         
01160 }
01161 
01162 <span class="keywordtype">double</span> Pic::rms_wavelength_h()
01163  {
01164   <span class="keywordtype">double</span> tem=0.0;
01165   <span class="keywordtype">int</span> n=pics.size();
01166   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++)
01167     tem+=<a class="code" href="classPic.html#a40">get_wavelength_h</a>(j)/n;   
01168   <span class="keywordflow">return</span> tem;
01169  }
01170 
01171 
01172 <span class="keywordtype">double</span> Pic::rms_wavelength_v()
01173  {
01174   <span class="keywordtype">double</span> tem=0.0;
01175   <span class="keywordtype">int</span> n=pics.size();
01176   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++)
01177     tem+=<a class="code" href="classPic.html#a41">get_wavelength_v</a>(j)/n;   
01178   <span class="keywordflow">return</span> tem;
01179  }
01180 
01181  
01182  <span class="keywordtype">double</span> Pic::rms_phaseadvance_h()
01183  {
01184   <span class="keywordtype">double</span> tem=0.0;
01185   <span class="keywordtype">int</span> n=pics.size();
01186   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++)
01187     tem+=get_phaseadvance_h(j)/n;   
01188   <span class="keywordflow">return</span> tem;
01189  }
01190 
01191 
01192 <span class="keywordtype">double</span> Pic::rms_phaseadvance_v()
01193  {
01194   <span class="keywordtype">double</span> tem=0.0;
01195   <span class="keywordtype">int</span> n=pics.size();
01196   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n; j++)
01197     tem+=get_phaseadvance_v(j)/n;   
01198   <span class="keywordflow">return</span> tem;
01199  }
01200 
</pre></div><hr><address style="align: right;"><small>Generated on Wed Oct 14 14:27:07 2009 for Track by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3 </small></address>
</body>
</html>
